/**
 ** -  JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */
options {
	static = false;
	ERROR_REPORTING = true;
	TRACK_TOKENS =true;
	TOKEN_EXTENDS ="BaseToken"; 
	COMMON_TOKEN_ACTION=true;
	//  DEBUG_PARSER = true;
}

PARSER_BEGIN(JASON)
package testJJ;

import java.io.InputStream;
import java.util.ArrayList;
import java.util.HashMap;

public class JASON {
	int errorCode = 0;
	String result = "";
	String errorMessage = "";
	int currentLevel;
	SymbolTableManager STManager;
	ArrayList<String> errorParams;
	ArrayList<Token> errorTokenParams;
	ArrayList<MepaCommand> codigoObj;
	HashMap<String,String> definitions;
	int currentLabel = 1;
	int offset = 0;
	int programSize = 0;
	boolean hasSubProg = false;
	boolean addedMainDSVS = false;
	int indexMainDSVS = 0;

	int classe_t;

    public String printCodObj() {
        StringBuilder result = new StringBuilder(); 
 
        for (int i=0;i<codigoObj.size(); i++) {
            result.append(codigoObj.get(i));
            result.append("\n");
        }
        return result.toString();
    }

	private void addCommand(String label, String c) {
		MepaCommand mc = new MepaCommand(c);
		mc.setLabel(label);
		codigoObj.add(mc);
	}

	private void addCommand(String label, String c, String p1) {
		MepaCommand mc = new MepaCommand(c);
		mc.setLabel(label);
		mc.setP1(p1);
		codigoObj.add(mc);
	}

	private void addCommand(String label, String c, String p1, String p2) {
		MepaCommand mc = new MepaCommand(c);
		mc.setLabel(label);
		mc.setP1(p1);
		mc.setP2(p2);
		codigoObj.add(mc);
	}

	private void addCommand(String label, String c, String p1, String p2, String labelParam) {
		MepaCommand mc = new MepaCommand(c);
		mc.setLabel(label);
		mc.setP1(p1);
		mc.setP2(p2);
		mc.setLabelParam(labelParam);
		codigoObj.add(mc);
	}

	private void addCommand(String label, String c, String p1, String p2, String labelParam, int i) {
		MepaCommand mc = new MepaCommand(c);
		mc.setLabel(label);
		mc.setP1(p1);
		mc.setP2(p2);
		mc.setLabelParam(labelParam);
		codigoObj.add(i,mc);
	}

	private void updateParamAddresses (Identifier proc) {		if (proc==null)
			return;
		ArrayList<Identifier> parameters = proc.getParameters();
		for (int i=0;i<parameters.size();i++) {
			parameters.get(i).setAddress(-2-(parameters.size()-i));		}
	}

	private void loadID(Identifier id) {
		if (id.getCategory() == SymbolTableManager.CATEGORY_PARAM &&
			id.getTransferType() == SymbolTableManager.TRANSFER_REF) {
			addCommand("","CRVI",
			new Integer(id.getLevel()).toString(),
			new Integer(id.getAddress()).toString());
		}
		else {
			addCommand("","CRVL",
			new Integer(id.getLevel()).toString(),
			new Integer(id.getAddress()).toString());
		}
	}

	private void loadRefParam(Identifier id) {
		MepaCommand mc = codigoObj.get(codigoObj.size()-1);
		mc.setCommand("CREN");
	}

	private void loadRefValue(Identifier id) {
		MepaCommand mc = codigoObj.get(codigoObj.size()-1);
		mc.setCommand("CRVL");
	}

	private void saveID(Identifier id) {
		if (id.getCategory() == SymbolTableManager.CATEGORY_PARAM &&
			id.getTransferType() == SymbolTableManager.TRANSFER_REF) {
			addCommand("","ARMI",
			new Integer(id.getLevel()).toString(),
			new Integer(id.getAddress()).toString());
		}
		else {
			addCommand("","ARMZ",
			new Integer(id.getLevel()).toString(),
			new Integer(id.getAddress()).toString());
		}
	}

	private void loadInt(Token t) {
		String v = t.image;

		addCommand("","CRCT",v);
	}

	private void loadReal(Token t) {
		String v = t.image;

		addCommand("","CRCT",v);
	}

	private void loadString(Token t) {
		// TODO
//		String v = t.image;////		addCommand("","CRCT",v);
	}

	private void doSumSub(Token t) {		switch (t.kind) {
		case OP_ADD:
			addCommand("","SOMA");
			break;
		case OP_SUB:
			addCommand("","SUBT");
			break; 
		}
	}

	private void doCompare(Token t) {
		switch (t.kind) {
		case OP_EQUALS:
			addCommand("","CMIG");
			break;
		case OP_DIFFERENT:
			addCommand("","CMDG");
			break; 
		case OP_GREATER_OR_EQUAL:
			addCommand("","CMAG");
			break; 
		case OP_LESS_OR_EQUAL:
			addCommand("","CMEG");
			break; 
		case OP_GREATER:
			addCommand("","CMMA");
			break; 
		case OP_LESS:
			addCommand("","CMME");
			break; 
		}
	}

	private void addEndCommands() {
		if (programSize>0)
			addCommand("","DMEM", new Integer(programSize).toString());
		addCommand("","PARA");	}

	private void addEndSubProgCommands(Identifier id, int size) {
		if (size>0)
			addCommand("","DMEM", new Integer(size).toString());
		addCommand("","RTPR",
		new Integer(id.getLevel()+1).toString(),
		new Integer(id.getParameters().size()).toString());
	}
	
	public void error(int error)  {
		error(error, generateParseException());
	}

	public void error(int error, ParseException e) {
		errorCode = error;
		boolean printed = true;
		
		switch (errorCode)
		{
		case ErrorConstants.ERR_CANT_SET: 			errorMessage += "Identificador ("+					errorParams.get(0)+					") na linha " + e.currentToken.beginLine + ", coluna "					+ e.currentToken.beginColumn + ", não pode ser modificado.";			break;
		case ErrorConstants.ERR_INT_OVERFLOW: 
			errorMessage += "Valor inteiro ("+
					errorParams.get(0)+
					") na linha " + e.currentToken.beginLine + ", coluna "
					+ e.currentToken.beginColumn +
					", não é valido. Inteiros devem estar entre -32768 e 32767.";
			break;
		case ErrorConstants.ERR_STRING_OVERFLOW: 
			errorMessage += "Strings não podem ser maiores do que"+
			" 255 caracteres, na linha " + e.currentToken.beginLine + ".";
			break;
		case ErrorConstants.ERR_PARAM_INCOMPATIBLE: 
			errorMessage += "Tipo de parâmetro incompatível na linha " +
			e.currentToken.beginLine + ", coluna "
					+ e.currentToken.beginColumn +
					".";
			break;
		case ErrorConstants.ERR_REAL_OVERFLOW: 
			errorMessage += "Valor real ("+
					errorParams.get(0)+
					") na linha " + e.currentToken.beginLine + ", coluna "
					+ e.currentToken.beginColumn +
					", não é valido. Reais devem estar entre -2147483648 e 2147483647.";
			break;
		case ErrorConstants.ERR_LOGIC_OP_INVALID: 			errorMessage += "Valor lógico inválido na linha " +			e.currentToken.beginLine + ".";			break;		case ErrorConstants.ERR_OP_MOD_INT_EXPECED: 			errorMessage += "Operador \"%\" espera apenas inteiros, na linha " +			e.currentToken.beginLine + ".";			break;		case ErrorConstants.ERR_BOOLEAN_READ: 			errorMessage += "Variável booleana não pode ser lida, na linha " +			e.currentToken.beginLine + ".";			break;		case ErrorConstants.ERR_STRING_OP: 			errorMessage += "Operador relacional que envolve string "+			"deve ser: string <relacional> string, na linha " +			e.currentToken.beginLine + ".";			break;		case ErrorConstants.ERR_BOOLEAN_OP:			errorMessage += "Apenas operadores \"=\" e \"!\" podem ser "+			"usados envolvendo booleans, na linha " +			e.currentToken.beginLine + ".";			break;		case ErrorConstants.ERR_NUM_OP:			errorMessage += "Operadores \"+\", \"-\", \"*\"ou \"\\\" "+			"podem apenas ser usados "+			"envolvendo inteiros ou reais, na linha " +			e.currentToken.beginLine + ".";			break;		case ErrorConstants.ERR_NUM_EXPECTED:			errorMessage += "Valor numérico esperado, na linha " +			e.currentToken.beginLine + ".";			break;		case ErrorConstants.ERR_INT_BOOL_EXPECTED:			errorMessage += "Valor inteiro ou booleano esperado, na linha " +			e.currentToken.beginLine + ".";			break;		case ErrorConstants.ERR_RETURN_INCOMPATIBLE:			errorMessage += "Tipo de retorno incompatível, na linha " +			e.currentToken.beginLine + ".";			break;		case ErrorConstants.ERR_INCOMPATIBLE_TYPES: 
			errorMessage += "Tipos incompativeis na linha " +
			e.currentToken.beginLine + ".";
			break;
		case ErrorConstants.ERR_PROCEDURE_NOT_DECLARED: 
			errorMessage += "Identificador ("+
					errorParams.get(0)+
					") na linha " + e.currentToken.beginLine + ", coluna "
					+ e.currentToken.beginColumn + ", não é um procedimento.";
			break;		case ErrorConstants.ERR_BOOLEAN_EXPECTED: 			errorMessage += "Boolean esperado, na linha " +			e.currentToken.beginLine + ".";			break;
		case ErrorConstants.ERR_DUPLICATE_IDENTIFIER: 
			errorMessage += "Identificador duplicado ("+
					errorParams.get(0)+
					") na linha " + e.currentToken.beginLine + ", coluna "
					+ e.currentToken.beginColumn;
			break;
		case ErrorConstants.ERR_IDENTIFIER_NOT_DECLARED: 
			errorMessage += "Identificador não declarado ("+
					errorParams.get(0)+
					") na linha " + e.currentToken.beginLine + ", coluna "
					+ e.currentToken.beginColumn;
			break;
		case ErrorConstants.ERR_FUNCTION_NOT_DECLARED: 
			errorMessage += "Função não declarada ("+
					errorParams.get(0)+
					") na linha " + e.currentToken.beginLine + ", coluna "
					+ e.currentToken.beginColumn;
			break;
		case ErrorConstants.ERR_TYPE_NOT_DECLARED: 
			errorMessage += "Tipo não declarado ("+
					errorParams.get(0)+
					") na linha " + e.currentToken.beginLine + ", coluna "
					+ e.currentToken.beginColumn;
			break;
		case ErrorConstants.ERR_REF_PARAM_READ_ONLY: 			errorMessage += "Identificador ("+					errorParams.get(0)+					") na linha " + e.currentToken.beginLine +					" não pode ser passado por referência";			break;		case ErrorConstants.ERR_REF_PARAM_INCOMPATIBLE: 			errorMessage += "Parâmetro na linha " + e.currentToken.beginLine +					" incompatível.";			break;
		case ErrorConstants.ERR_N_PAR_INCOMPATICLE: 
			errorMessage += "Incompatibilidade no número "+
			"de parâmetros na linha " + e.currentToken.beginLine + ", coluna "
					+ e.currentToken.beginColumn;
			break;
		case ErrorConstants.ERR_FPVC_NOT_DECLARED: 			errorMessage += "Função, parâmetro, variável ou constante não declarada ("+					errorParams.get(0)+					") na linha " + e.currentToken.beginLine + ", coluna "					+ e.currentToken.beginColumn;			break;		case ErrorConstants.ERR_VP_NOT_DECLARED: 			errorMessage += "Parâmetro ou variável não declarada ("+					errorParams.get(0)+					") na linha " + e.currentToken.beginLine + ", coluna "					+ e.currentToken.beginColumn;			break;
		case ErrorConstants.ERR_NEGATIVE_ARRAY: 
			errorMessage += "Array de tamanho não positivo "+
				"na linha " +
				errorTokenParams.get(0).beginLine + ", coluna "+
				errorTokenParams.get(0).beginColumn;
			break;
		default:
			printed = false;
		}
		if (printed)
			errorMessage += "\n--------\n";
	}

	public boolean validLogicType(Identifier id) {
		if (id==null)
			return false;
		if (id == STManager.getTypeBoolean() ||
			id == STManager.getTypeInteger())
			return true;
		return false;
	}

	public void testInteger(Identifier id) {
		if (id != STManager.getTypeInteger())
			error(ErrorConstants.ERR_INT_EXPECED, generateParseException());
	}

	public void testParamReference(Identifier id,
				Identifier varParam, int nArg) {
		if (id==null)
			return;
		else if (id.getParameters().size()==0)
			return;
		else if (id.getParameters().get(nArg-1).getTransferType() == SymbolTableManager.TRANSFER_REF) {
			if (varParam == null) {
				error(ErrorConstants.ERR_REF_PARAM_INCOMPATIBLE, generateParseException());
			}
			if (varParam.getCategory() != SymbolTableManager.CATEGORY_VAR &&
				varParam.getCategory() != SymbolTableManager.CATEGORY_PARAM)			{
				errorParams = new ArrayList<String>();
				errorParams.add(varParam.getID());
				error(ErrorConstants.ERR_REF_PARAM_READ_ONLY,generateParseException());			}
			if (!(varParam.getCategory() == SymbolTableManager.CATEGORY_PARAM &&
				  varParam.getTransferType() == SymbolTableManager.TRANSFER_REF))
				loadRefParam(varParam);
			else
				loadRefValue(varParam);		}	}

	public void testParamType(Identifier id,
				Identifier tipo, int nArg) {
		if (id==null)
			return;
		else if (id.getParameters().size()==0)
			return;
		else if (id.getParameters().get(nArg-1).getType() != tipo) {
			error(ErrorConstants.ERR_PARAM_INCOMPATIBLE,generateParseException());
		}
	}

	/*
	Cria identificador na tabela de símbolos, lança erro se for duplicado.
	*/
	public Identifier createIdentifier(Token t) {
		Identifier id = new Identifier();
		id.setID(t.image.toUpperCase());
		id.setLevel(currentLevel);

		if (!STManager.addSymbol(id)) {
			errorParams = new ArrayList<String>();
			errorParams.add(id.getID());
			error(ErrorConstants.ERR_DUPLICATE_IDENTIFIER,generateParseException());
		}
		return id;
	}

	/*
	Define categoria, tipo e valor de identificador.
	*/
	public void r0a(Identifier id, int cat, Identifier type, String value) {
		if (id==null)
			return;
		id.setCategory(cat);
		id.setType(type);
		id.setValue(value);
	}

	/*
	Cria identificador na tabela de símbolos, lança erro se for duplicado.
	Define categoria como "tipo".
	*/
	public Identifier r1(Token t) {
		Identifier id = new Identifier();
		id.setID(t.image.toUpperCase());
		id.setLevel(currentLevel);
		id.setCategory(SymbolTableManager.CATEGORY_TYPE);

		if (!STManager.addSymbol(id)) {
			errorParams = new ArrayList<String>();
			errorParams.add(id.getID());
			error(ErrorConstants.ERR_DUPLICATE_IDENTIFIER,generateParseException());
		}

		return id;
	}

	/*
	Cria identificador na tabela de símbolos, lança erro se for duplicado.
	Define categoria como "variavel" e atualiza seu tipo.
	*/
	public void r3(Token t, Identifier type) {
		Identifier id = new Identifier();
		id.setID(t.image.toUpperCase());
		id.setLevel(currentLevel);
		id.setType(type);
		id.setCategory(SymbolTableManager.CATEGORY_VAR);

		if (!STManager.addSymbol(id)) {
			errorParams = new ArrayList<String>();
			errorParams.add(id.getID());
			error(ErrorConstants.ERR_DUPLICATE_IDENTIFIER,generateParseException());
		}
	}
	
	/*
	Cria identificador na tabela de símbolos, lança erro se for duplicado.
	Define categoria como "procedimento".
	*/
	public Identifier r5(Token t) {
		Identifier id = new Identifier();
		id.setID(t.image.toUpperCase());
		id.setLevel(currentLevel);
		id.setCategory(SymbolTableManager.CATEGORY_PROCEDURE);
		id.setLabel("L"+currentLabel);
		currentLabel++;
		if (!STManager.addSymbol(id)) {
			errorParams = new ArrayList<String>();
			errorParams.add(id.getID());
			error(ErrorConstants.ERR_DUPLICATE_IDENTIFIER,generateParseException());
		}
		return id;
	}

	/*
	Cria identificador na tabela de símbolos, lança erro se for duplicado.
	Define categoria como "função".
	*/
	public Identifier r6(Token t) {
		Identifier id = new Identifier();
		id.setID(t.image.toUpperCase());
		id.setLevel(currentLevel);
		id.setCategory(SymbolTableManager.CATEGORY_FUNCTION);
		id.setLabel("L"+currentLabel);
		currentLabel++;
		if (!STManager.addSymbol(id)) {
			errorParams = new ArrayList<String>();
			errorParams.add(id.getID());
			error(ErrorConstants.ERR_DUPLICATE_IDENTIFIER,generateParseException());
		}
		return id;
	}

	/*
	Define tipo do identificador.
	*/
	public void r7(Identifier id, Identifier type){
		if (id==null)
			return;
		id.setType(type);
	}

	/*
	Busca identificador de categoria "tipo", lança erro se não foi declarado
	ou se não for um "tipo".
	*/
	public Identifier r7a(Token t) {
		Identifier id = STManager.getIdentifier(t.image);
		if (id == null) {
			errorParams = new ArrayList<String>();
			errorParams.add(t.image);
			error(ErrorConstants.ERR_TYPE_NOT_DECLARED,generateParseException());
		}
		else if (id.getCategory() != SymbolTableManager.CATEGORY_TYPE) {
			errorParams = new ArrayList<String>();
			errorParams.add(id.getID());
			error(ErrorConstants.ERR_TYPE_NOT_DECLARED,generateParseException());
		}
		return id;
	}

	/*
	Remove símbolos do último nível da tabela de símbolos.
	*/
	public void r8(Identifier id) {
		STManager.removeLevel(currentLevel);
		currentLevel--;
	}

	/*
	Define tipo do identificador como Array.
	*/
	public void r10(Identifier id) {
		if (id==null)
			return;
		id.setType(STManager.getTypeArray());
	}

	/*
	Define tipo do identificador como Record.
	*/
	public void r10a(Identifier id) {
		if (id==null)
			return;
		id.setType(STManager.getTypeRecord());
	}

	/*
	Define o tamanho, tipo e número de bytes do array,
	lança erro se o tamanho não for positivo.
	*/
	public void r12(Identifier id, Token t, Identifier dt, int minusCount) {
		if (id==null || dt==null)
			return;
		int size = new Integer(t.image);
		if (size<=0 || minusCount%2!=0) {
			errorTokenParams = new ArrayList<Token>();
			errorTokenParams.add(t);
			error(ErrorConstants.ERR_NEGATIVE_ARRAY,generateParseException());
		}
		id.setArraySize(size);
		id.setArrayType(dt);
		id.setNBytes(dt.getNBytes()*id.getArraySize());
	}

	/*
	Busca campo declarado no Record e returna true ou false
	se foi ou não encontrado.
	*/
	public boolean arrayContainsID(ArrayList<Identifier> list, String name) {
		for (int i=0;i<list.size();i++)		{			if (list.get(i).getID().toUpperCase().equals(name.toUpperCase()))
				return true;
		}
		return false;	}

	/*
	Adiciona campo no Record, lança erro se for duplicado.
	Define categoria como "variavel" e atualiza seu tipo e número de bytes.
	*/
	public void r12a(Identifier id, Token t, Identifier dt) {
		if (id==null || dt==null)
			return;
		Identifier aux = new Identifier();
		aux.setID(t.image.toUpperCase());
		aux.setLevel(currentLevel);
		aux.setType(dt);
		aux.setCategory(SymbolTableManager.CATEGORY_VAR);
		
		id.setNBytes(id.getNBytes()+dt.getNBytes());
		if (arrayContainsID(id.getRecordTypes(),aux.getID()))		{
			errorParams = new ArrayList<String>();
			errorParams.add(aux.getID());
			error(ErrorConstants.ERR_DUPLICATE_IDENTIFIER,generateParseException());
		}
		id.getRecordTypes().add(aux);
	}

	/*
	Define classe de transferência atual como "Valor".
	*/
	public void r14() {
		classe_t = SymbolTableManager.TRANSFER_VALUE;
	}

	/*
	Define classe de transferência atual como "Referência".
	*/
	public void r15() {
		classe_t = SymbolTableManager.TRANSFER_REF;
	}

	/*
	Cria identificador na tabela de símbolos, lança erro se for duplicado.
	Define categoria como "parâmetro" e atualiza seu
	tipo, classe de transferência e tipo.
	*/
	public void r18(Identifier proc, Token t, Identifier dt) {
		if (proc==null || dt==null)
			return;
		Identifier id = new Identifier();
		id.setID(t.image.toUpperCase());
		id.setLevel(currentLevel);
		id.setCategory(SymbolTableManager.CATEGORY_PARAM);
		id.setTransferType(classe_t);
		id.setType(dt);
		proc.getParameters().add(id);

		if (!STManager.addSymbol(id)) {
			errorParams = new ArrayList<String>();
			errorParams.add(id.getID());
			error(ErrorConstants.ERR_DUPLICATE_IDENTIFIER,generateParseException());
		}
	}

	/*
	Busca identificador na tabela de símbolos, lança erro se não foi declarado.
	*/
	public Identifier r21(Token t) {
		Identifier id = STManager.getIdentifier(t.image);
		if (id==null) {
			errorParams = new ArrayList<String>();
			errorParams.add(t.image.toUpperCase());
			error(ErrorConstants.ERR_IDENTIFIER_NOT_DECLARED,generateParseException());
		}

		return id;
	}

	/*
	Busca campo de record na tabela de símbolos,
	lança erro se não foi declarado.
	*/
	public Identifier r21a(Identifier id,Token t) {
		if (id==null)
			return null;
		Identifier aux = null;
		try {
			aux = STManager.getRecordIdentifier(id,t.image);
		} catch (Exception e) {}
		if (aux==null) {
			errorParams = new ArrayList<String>();
			errorParams.add(t.image.toUpperCase());
			error(ErrorConstants.ERR_IDENTIFIER_NOT_DECLARED,generateParseException());
		}

		return aux;
	}

	/*
	Lança erro se a função usada não foi declarada
	*/
	public void r22(Identifier id) {
		if (id==null)
			return;
		if (id.getCategory() != SymbolTableManager.CATEGORY_FUNCTION)
		{
			errorParams = new ArrayList<String>();
			errorParams.add(id.getID());
			error(ErrorConstants.ERR_FUNCTION_NOT_DECLARED,generateParseException());
		}
	}

	/*
	Lança erro se a categorie do identificador não for
	função, parâmetro, variável ou constante.
	*/
	public void r22a(Identifier id) {
		if (id==null)
			return;
		if (id.getCategory() != SymbolTableManager.CATEGORY_FUNCTION &&
			id.getCategory() != SymbolTableManager.CATEGORY_PARAM &&
			id.getCategory() != SymbolTableManager.CATEGORY_VAR &&
			id.getCategory() != SymbolTableManager.CATEGORY_CONST)
		{
			errorParams = new ArrayList<String>();
			errorParams.add(id.getID());
			error(ErrorConstants.ERR_FPVC_NOT_DECLARED,generateParseException());
		}
	}

	/*
	Lança erro se o número de parâmetros for incorreto.
	*/
	public void r24(Identifier id, int nPar) {
		if (id==null)
			return;
		if (id.getCategory() != SymbolTableManager.CATEGORY_PROCEDURE &&
			id.getCategory() != SymbolTableManager.CATEGORY_FUNCTION)
			return;
		if (id.getParameters().size() != nPar){
			error(ErrorConstants.ERR_N_PAR_INCOMPATICLE,generateParseException());
		}
	}

	/*
	Lança erro se o procedimento usado não foi declarada
	*/
	public void r25(Identifier id)  {
		if (id==null)
			return;
		if (id.getCategory() != SymbolTableManager.CATEGORY_PROCEDURE)
		{
			errorParams = new ArrayList<String>();
			errorParams.add(id.getID());
			error(ErrorConstants.ERR_PROCEDURE_NOT_DECLARED,generateParseException());
		}
	}

	/*
	Lança erro se o valor inteiro for maior do que o limite.
	*/
	public void r26i(Token t, boolean minus) {
		Integer i = null;
		try {
			i = new Integer(t.image);
			if (minus)
				i = -i;
		} catch (Exception e) {
			errorParams = new ArrayList<String>();
			errorParams.add(t.image);
			error(ErrorConstants.ERR_INT_OVERFLOW,generateParseException());
			return;
		}
		if (i<-32768 || i>32767) {
			errorParams = new ArrayList<String>();
			errorParams.add(t.image);
			error(ErrorConstants.ERR_INT_OVERFLOW,generateParseException());
		}
	}

	/*
	Lança erro se o valor real for maior do que o limite.
	*/
	public void r26r(Token t, boolean minus) {
		Double d = null;
		try {
			d = new Double(t.image);
			if (minus)
				d = -d;
		} catch (Exception e) {
			errorParams = new ArrayList<String>();
			errorParams.add(t.image);
			error(ErrorConstants.ERR_REAL_OVERFLOW,generateParseException());
			return;
		}
		if (d<-2147483648d || d>2147483647d) {
			errorParams = new ArrayList<String>();
			errorParams.add(t.image);
			error(ErrorConstants.ERR_REAL_OVERFLOW,generateParseException());
		}
	}

	/*
	Lança erro se a string for maior do que o limite.
	*/
	public void r26s(Token t) {
		if (t.image.length()>255) {
			errorParams = new ArrayList<String>();
			errorParams.add(t.image);
			error(ErrorConstants.ERR_STRING_OVERFLOW,generateParseException());
		}
	}

	/*
	Lança erro se o identificador não puder ser alterado.
	*/
	public void r27(ArrayList<Identifier> ids) {
		if (ids==null || ids.size()<=0)
			return;
		Identifier id = ids.get(ids.size()-1);
		if (id==null)
			return;
		if (id.getCategory() != SymbolTableManager.CATEGORY_PARAM &&
			id.getCategory() != SymbolTableManager.CATEGORY_VAR)
		{
			String s = ids.get(0).getID();
			for (int i=1;i<ids.size();i++) {
				s = s+"."+ids.get(i);
			}
			errorParams = new ArrayList<String>();
			errorParams.add(s);
			error(ErrorConstants.ERR_CANT_SET,generateParseException());
		}
	}

	/*
	Lança erro se a variável ou parâmetro não for declarado.
	*/
	public void rVP(Identifier id) {
		if (id==null)
			return;
		if (id.getCategory() != SymbolTableManager.CATEGORY_PARAM &&
			id.getCategory() != SymbolTableManager.CATEGORY_VAR)
		{
			errorParams = new ArrayList<String>();
			errorParams.add(id.getID());
			error(ErrorConstants.ERR_VP_NOT_DECLARED,generateParseException());
		}
	}

	public int getErrorCode()
	{
		return errorCode;
	}

	public String getErrorMessage()
	{
		return errorMessage;
	}

	public String testParser(InputStream is)	{
		ReInit(is);
		result = "";
		errorCode = 0;
		int currentLevel = 0;
		STManager = new SymbolTableManager();
		codigoObj = new ArrayList< MepaCommand>();

		try {
			this.Program();
			result += "OK.\u005cn";
		}
		catch (NullPointerException e) {}
		catch (Exception e) {
			errorCode = -1;
			errorMessage += e.getMessage() + "\u005cn";
			ReInit(is);
		} catch (Error e) {
			errorCode = -1;
			errorMessage += e.getMessage() + "\u005cn";
		}
		return result;
	}
}

PARSER_END(JASON)

SKIP :
{
	" "
	| "\r"
	| "\r\n"
	| "\t"
	| "\n"
}

SPECIAL_TOKEN:
{
		<COMMENT_LINE: "#" (~["\n","\r","\r"])* >
		| < COMMENT_INNER : "{" >: IN_COMMENT
		| < COMMENT_BLOCK : "{" (~["}"])* "}" >
}


	< IN_COMMENT > TOKEN : {
		< COMMENT_CORE: (~["}"])* > : DEFAULT
	}

	TOKEN [IGNORE_CASE] : /* RESERVED WORDS */
	{
		< ARRAY : "ARRAY" >
		| < BEGIN : "BEGIN" >
		| < CALL : "CALL" >
		| < DO : "DO" >
		| < ELSE : "ELSE" >
		| < END : "END" >
		| < ENDIF : "ENDIF" >
		| < ENDUNTIL : "ENDUNTIL" >
		| < ENDWHILE : "ENDWHILE" >
		| < FUNCTION : "FUNCTION" >
		| < IF : "IF" >
		| < INTEGER : "INTEGER" >
		| < PARAMETERS : "PARAMETERS" >
		| < PROCEDURE : "PROCEDURE" >
		| < RETURNS : "RETURNS" >
		| < PROGRAM : "PROGRAM" >
		| < READ : "READ" >
		| < REAL : "REAL" >
		| < RECORD : "RECORD" >
		| < RETURN : "RETURN" >
		| < SET : "SET" >
		| < STRING : "STRING" >
		| < THEN : "THEN" >
		| < TYPES : "TYPES" >
		| < UNTIL : "UNTIL" >
		| < VAR : "VAR" >
		| < VARIABLES : "VARIABLES" >
		| < WHILE : "WHILE" >
		| < WRITE : "WRITE" >
		| < BOOLEAN : "BOOLEAN" >
		| < TRUE : "TRUE" >
		| < FALSE : "FALSE" >
		| < DEFINE : "DEFINE" >
	}

	TOKEN : /* OPERATORS */
	{
		< OP_ADD : "+" >
		| < OP_SUB : "-" >
		| < OP_MULT : "*" >
		| < OP_DIV : "/" >
		| < OP_MOD : "%" >
		| < OP_EQUALS: "=" >
		| < OP_LESS: "<" >
		| < OP_GREATER: ">" >
		| < OP_LESS_OR_EQUAL: "<=" >
		| < OP_GREATER_OR_EQUAL: ">=" >
		| < OP_DIFFERENT: "!" >
	}

	TOKEN : /* SYMBOLS */
	{
		< BRACKET_OPEN : "[" >
		| < BRACKET_CLOSE : "]" >
		| < PARENTHESIS_OPEN : "(" >
		| < PARENTHESIS_CLOSE: ")" >
		| < COMMA : "," >
		| < DOT : "." >
		| < SEMICOLON  : ";" >
		| < AND : "&" >
		| < OR : "\\" >
		| < NOT : "~" >
	}

	TOKEN :
	{
		< INTEGER_CONST : (< DIGIT >)+ >
		| < REAL_CONST : (< DIGIT >)+"."(< DIGIT >)* | "."(< DIGIT >)+ >
		| < #DIGIT : [ "0"-"9" ] >
	}

	TOKEN [IGNORE_CASE]:
	{
		< IDENTIFIER : [ "a"-"z", "_" ]([ "a"-"z" , "0"-"9", "_"]){0,62} >
		| < IDENTIFIER_ERR : [ "a"-"z", "_" ]([ "a"-"z" , "0"-"9", "_"]){63,} >
	}

	SPECIAL_TOKEN:
	{
		< STRING_START : "\"" >: IN_STRING
	}

	< IN_STRING > TOKEN :
	{
		< STRING_CORE:  (~["\""])* > : DEFAULT 
	}

	TOKEN [IGNORE_CASE]:
	{
		< STRING_CONST : "\"" (~["\""])*  "\"" > 
	}


	void Program(): {} {
		{ addCommand("","INPP"); }
		Header() { programSize = DeclSec(); }
		{ if (hasSubProg) addCommand("L1","NADA");}
		Block() { addEndCommands(); } <DOT> }
	void Header(): {} { <PROGRAM> <IDENTIFIER> <SEMICOLON> }
	void Block(): {} { <BEGIN> Statements() <END> }

	//Declarações

	int DeclSec(): {int size = 0;} { 
		(DefineDeclSec())? (TypeDeclSec())? (size = VarDeclSec())?
		( {
			if (!hasSubProg) {
				hasSubProg = true;
				indexMainDSVS = codigoObj.size();
				currentLabel++;
			}
		  }
			SubProgramDecls())?
		{
			if (hasSubProg && !addedMainDSVS) {
				addedMainDSVS = true;
				addCommand("","DSVS","","","L1",indexMainDSVS);
			}
		}
		{ return size; } 
	}

	void DefineDeclSec():
	{
		Token t;
		Identifier type[] = new Identifier[1];
		String value[] = new String[1];
	} { 
		<DEFINE> ( t = <IDENTIFIER> { Identifier id = createIdentifier(t);}
		<OP_EQUALS> Values(id, type,value)
		<SEMICOLON> {r0a(id,SymbolTableManager.CATEGORY_CONST,type[0],value[0]);})+ 
	}

	String Values(Identifier id, Identifier type[], String value[]): {Token t1 = null; Token t2;} {
		{ boolean minus = false;}
		( ( t1 = <OP_SUB> { minus = true;} )?
				( t2 = <INTEGER_CONST> { r26i(t2,minus); }
				{type[0] = STManager.getTypeInteger();value[0]=t2.image;}
				| t2 = <REAL_CONST> { r26r(t2,minus); }
				{type[0] = STManager.getTypeReal();value[0]=t2.image;})
				| t2 = <STRING_CONST> { r26s(t2); }
				{type[0] = STManager.getTypeString();value[0]=t2.image;})
		{
			String s = "";
			if (t1 != null)
				s = s+t1.image.toUpperCase();
			s = s+t2.image.toUpperCase();
			return s;
		}
	}

	void TypeDeclSec(): {Token t; Identifier id;} { 
		<TYPES> ( t = <IDENTIFIER> {id = r1(t);} ( ArraySpecification(id) |
		RecordSpecification(id) ) <SEMICOLON> )+ 
	}

	void ArraySpecification(Identifier id): {Identifier dt;Token t;int minusCount = 0;} {
		<ARRAY> {r10(id);}
		dt = DataType() <BRACKET_OPEN>
		( t = <INTEGER_CONST> { r26i(t,false); } {r12(id,t,dt,0);}
		| (<OP_SUB> {minusCount++;} |
		  <OP_ADD> )+ t = <INTEGER_CONST> { r26i(t,false); } {r12(id,t,dt,minusCount);}
		)
		<BRACKET_CLOSE>
	}

	void RecordSpecification(Identifier id): {} { 
		<RECORD> {r10a(id);} VarDeclsRecord(id) <END>
	}

	void VarDeclsRecord(Identifier id): {Identifier dt;} {
		( dt = DataType() IdListRecord(id,dt) <SEMICOLON> )+
	}

	int VarDeclSec(): { int size = 0; } { 
		<VARIABLES> size = VarDecls()
		{ return size; } 
	}

	int VarDecls(): {Identifier dt; int size = 0;} {
		( dt = DataType() { size += IdList(dt); } <SEMICOLON> )+
		{ return size; }
	}

	Identifier DataType(): {Token t; Identifier id;} {
		(
			t = <REAL> {id = STManager.getTypeReal(); } |
			t = <INTEGER> {id = STManager.getTypeInteger(); } |
			t = <IDENTIFIER> { id = r7a(t); } |
			t = <STRING> {id = STManager.getTypeString(); } |
			t = <BOOLEAN> {id = STManager.getTypeBoolean(); } )
		{
			return id;
		}
	}

	int IdList(Identifier dt): {Token t; int varCont = 0;} {
		t = <IDENTIFIER>
		{r3(t,dt); varCont++;}
		( <COMMA> t = <IDENTIFIER>
		{r3(t,dt); varCont++;}
		)*
		{ addCommand("","AMEM",new Integer(varCont).toString());
		return varCont;
		}
	}

	void IdListRecord(Identifier id, Identifier dt): {Token t;} {
		t = <IDENTIFIER>
		{r12a(id,t,dt);}
		( <COMMA> t = <IDENTIFIER>
		{r12a(id,t,dt);}
		)*
	}

	void SubProgramDecls(): {} { 
		( ProcDecl() | FunctionDecl() )+ 
	}

	void ProcDecl(): {Identifier id; int size = 0;} {
		id = ProcHeader() { currentLevel++; }
		{ size = SubProgramDeclSec(id); } Block()
		{
			addEndSubProgCommands(id,size);
			r8(id);
		}
		<SEMICOLON>
	}

	Identifier ProcHeader(): {Token t;} {
		<PROCEDURE> t = <IDENTIFIER>
		{
			Identifier id = r5(t);
			addCommand(id.getLabel(),"ENPR",new Integer(id.getLevel()+1).toString());
		} <SEMICOLON>
		{ return id; }
	}

	int SubProgramDeclSec(Identifier proc): {int size = 0;} {
		(ParamDeclSec(proc))? { size = DeclSec(); return size; } 
	}

	void ParamDeclSec(Identifier proc): {Identifier dt;Token t;} {
		<PARAMETERS> ( {r14();} (<VAR> {r15();})?
				dt = DataType()
		t = <IDENTIFIER> {r18(proc,t,dt);}
		<SEMICOLON> )+

		{
			updateParamAddresses(proc);		}
	} 

	void FunctionDecl(): {Identifier id; int size = 0;} {
		id = FunctionHeader() { currentLevel++; }
		{ size = SubProgramDeclSec(id); } FunctionBlock(id)
		{
			addEndSubProgCommands(id,size);
			r8(id);
		}

		<SEMICOLON>
	}

	Identifier FunctionHeader(): {Token t;Identifier dt;} {
		<FUNCTION> t = <IDENTIFIER> { Identifier id = r6(t); }
		<RETURNS> dt = DataType() {r7(id,dt);}
		<SEMICOLON>
		{ return id; }
	}
	void FunctionBlock(Identifier f): {Identifier id[] = new Identifier[1];} {
		<BEGIN> ( Statement() <SEMICOLON> )+  <RETURN>
		<PARENTHESIS_OPEN> Condition(id)		{
			if (f.getType() != id[0])
			error(ErrorConstants.ERR_RETURN_INCOMPATIBLE);		}
		<PARENTHESIS_CLOSE> <END>
	}

	//Comandos

	void Statements(): {} { Statement() ( <SEMICOLON> Statement() )* }
	void Statement():
	{Identifier t1[], t2[]; Token t; ArrayList<Identifier> ids; Identifier id;} {
		{
			t1 = new Identifier[1];
			t2 = new Identifier[1];
		} 
		( <READ> ids = Variable(t1) 
			{
				addCommand("","IMPR");
				saveID(ids.get(ids.size()-1)); 
				r27(ids);
				if (t1[0] == STManager.getTypeBoolean())
					error(ErrorConstants.ERR_BOOLEAN_READ);
			}
		| <SET> ids = Variable(t1) { r27(ids); } <OP_EQUALS> Expression(t2)
			{
				if (t1[0] != t2[0]) {
					error(ErrorConstants.ERR_INCOMPATIBLE_TYPES);
				}
				saveID(ids.get(ids.size()-1));
			}
		| <WRITE> ids = Variable(t1)
			{ loadID(ids.get(ids.size()-1)); addCommand("","IMPR"); } 
		| <IF> Condition(t1) <THEN>
			{
				String L1 = "L"+currentLabel;
				currentLabel++;
				String L2 = "L"+currentLabel;
				currentLabel++;
		
				addCommand("","DSVF",L1);
			}
			Statements()
			{
				addCommand("","DSVS",L2);
				addCommand(L1,"NADA");
			}
			ElseClause()
			{ addCommand(L2,"NADA"); }
			{
				if (t1[0] != STManager.getTypeBoolean())
					error(ErrorConstants.ERR_BOOLEAN_EXPECTED);
			}
		| <WHILE> Condition(t1) <DO> Statements() <ENDWHILE>
			{
				if (t1[0] != STManager.getTypeBoolean()) 
					error(ErrorConstants.ERR_BOOLEAN_EXPECTED);
			}
		| <UNTIL> Condition(t1) <DO> Statements() <ENDUNTIL> 
			{
				if (t1[0] != STManager.getTypeBoolean()) 
					error(ErrorConstants.ERR_BOOLEAN_EXPECTED);
			}
		| <CALL> t = <IDENTIFIER> { id = r21(t); r25(id); } ArgList(id)
		{ addCommand("","CHPR",id.getLabel()); }
		  )?
	}

	void ElseClause(): {} {
		( <ELSE> Statements() )? <ENDIF> 
	}

	void ArgList(Identifier id): {Token t = null; int nPar;} {
		( t = <PARENTHESIS_OPEN> nPar = Arguments(id) <PARENTHESIS_CLOSE>  {r24(id,nPar);} )?
	}

	int Arguments(Identifier id): {int nArg = 1; Identifier varParam = null;} {
		{ Identifier tipo[] = new Identifier[1]; }
		varParam = Condition(tipo)
		{
			testParamReference(id,varParam,nArg); testParamType(id,tipo[0],nArg);
		}
		(<COMMA> varParam = Condition(tipo)
		{
			nArg++;
			testParamReference(id,varParam,nArg); testParamType(id,tipo[0],nArg);
		})*
		{ return nArg; }
	}


	//Expressões
	Identifier Condition(Identifier tipo[]): {Identifier varParam = null; Identifier t1[], t2[];} {
		{
			boolean c2 = false;
			t1 = new Identifier[1];
			t2 = new Identifier[1];
		}
		varParam = CompoundCondition(t1)
		( <OR> CompoundCondition(t2)
		{
			varParam = null;
			if (!(validLogicType(t1[0]) && validLogicType(t2[0])))
				error(ErrorConstants.ERR_BOOLEAN_EXPECTED);
				tipo[0] = STManager.getTypeBoolean();
			c2 = true;
		}
		)*
		{
			if (!c2 && tipo!=null) tipo[0] = t1[0]; 
		}
		{ return varParam; }
	}

	Identifier CompoundCondition(Identifier tipo[]):
		{Identifier varParam = null; Identifier t1[], t2[];} {
		{
			boolean c2 = false;
			t1 = new Identifier[1];
			t2 = new Identifier[1];
		}
		varParam = SimpleCondition(t1) ( <AND> SimpleCondition(t2)
		{
			varParam = null;
			if (validLogicType(t1[0]) && validLogicType(t2[0]))
				tipo[0] = STManager.getTypeBoolean();
			else error(ErrorConstants.ERR_BOOLEAN_EXPECTED);
			c2 = true;
		}
		)* 
		{
			if (!c2) tipo[0] = t1[0];
		}
		{ return varParam; }
	}

	Identifier SimpleCondition(Identifier tipo[]):
		{Identifier varParam = null; Identifier t1[], t2[]; Token t;} {
		{
			boolean c2 = false;
			t1 = new Identifier[1];
			t2 = new Identifier[1];
		}
		varParam = Expression(t1) ( 
		( t = <OP_EQUALS> | t = <OP_DIFFERENT> | t = <OP_GREATER_OR_EQUAL> | t = <OP_LESS_OR_EQUAL> | t = <OP_LESS> | t = <OP_GREATER> )
		 Expression(t2)
		{
			varParam = null;
			if ((t1[0] == STManager.getTypeString() && t2[0] != STManager.getTypeString())
				|| (t1[0] != STManager.getTypeString() && t2[0] == STManager.getTypeString()))
				error(ErrorConstants.ERR_STRING_OP);
			else if ((t.kind != OP_EQUALS && t.kind != OP_DIFFERENT &&
					  t.kind != OP_GREATER_OR_EQUAL && t.kind != OP_LESS_OR_EQUAL &&
					  t.kind != OP_GREATER && t.kind != OP_LESS) && 
					(validLogicType(t1[0]) || validLogicType(t2[0])))
					error(ErrorConstants.ERR_BOOLEAN_OP);
			else tipo[0] = STManager.getTypeBoolean();
			c2 = true;

			doCompare(t);
		}
		)?
		{
			if (!c2) tipo[0] = t1[0]; 
		}
		{ return varParam; }
	}

	Identifier Expression(Identifier tipo[]):
		{Identifier varParam = null; Identifier t1[], t2[]; Token t;} {
		{
			boolean c2 = false;
			t1 = new Identifier[1];
			t2 = new Identifier[1];
		}
		varParam = Term(t1) ( ( t = <OP_ADD> | t = <OP_SUB> ) Term(t2)
		{ doSumSub(t); }
		{
			varParam = null;
			if (t1[0] == STManager.getTypeInteger() && t2[0] == STManager.getTypeInteger())
				tipo[0] = STManager.getTypeInteger();
			else if ((t1[0] == STManager.getTypeInteger() || t1[0] == STManager.getTypeReal()) && (t2[0] == STManager.getTypeInteger() || t2[0] == STManager.getTypeReal()))
				tipo[0] = STManager.getTypeReal();
			else error(ErrorConstants.ERR_NUM_OP);
			c2 = true;

			//aaaaaaaaa
		}
		)*
		{
			if (!c2) tipo[0] = t1[0]; 		}
		{ return varParam; }
	}

	Identifier Term(Identifier tipo[]):
		{Identifier varParam = null; Identifier t1[], t2[]; Token t;} {
		{
			t1 = new Identifier[1];
			t2 = new Identifier[1];
			boolean c2 = false;
		}
		{ boolean minus = false; }
		varParam = Unary(t1,minus,false) ( ( t = <OP_MULT> | t = <OP_DIV> | t = <OP_MOD> )
		{ minus = false; }
		{ varParam = null; }
		Unary(t2,minus,false)
		{
			if (t.kind == OP_MOD && (t1[0] != STManager.getTypeInteger() || t2[0] != STManager.getTypeInteger())) error(ErrorConstants.ERR_OP_MOD_INT_EXPECED);
			else if (t1[0] == STManager.getTypeInteger() && t2[0] == STManager.getTypeInteger())
				tipo[0] = STManager.getTypeInteger();
			else if ((t1[0] == STManager.getTypeInteger() || t1[0] == STManager.getTypeReal()) && (t2[0] == STManager.getTypeInteger() || t2[0] == STManager.getTypeReal()))
				tipo[0] = STManager.getTypeReal();
			else error(ErrorConstants.ERR_NUM_OP);
			c2 = true;
		}	
		)*
		 {		 	if (!c2 && tipo!=null)
			tipo[0] = t1[0];
		}
		{ return varParam; }
	}

	Identifier Unary(Identifier tipo[], boolean minus, boolean hasSign):
		{Identifier varParam = null; Token t = null; Identifier t1[]; } {
		{ t1 = new Identifier[1]; }
		(	(
				<OP_ADD> { hasSign = true; } |
				<OP_SUB> { minus = !minus; varParam = null; }
			)
			varParam = Unary(t1,minus,hasSign) { tipo[0] = t1[0]; } |
			varParam = Factor(minus,t1)
			{
				if (hasSign) {
					varParam = null;
					if (t1[0] == STManager.getTypeInteger() || t1[0] == STManager.getTypeReal()) 
						tipo[0] = t1[0];
					else error(ErrorConstants.ERR_NUM_EXPECTED);
				}
				else {
					tipo[0] = t1[0];
				}
			}
		)
		{ return varParam; }
	}
	
	// Apenas faz atribuição de tipos (exceção not)
	Identifier Factor(boolean minus, Identifier tipo[]):
		{Identifier varParam = null; Token t; int nPar; Identifier t1[];} {
		{ t1 = new Identifier[1]; }
		(
			Bool() {tipo[0] = STManager.getTypeBoolean();} |
			t = <IDENTIFIER> { Identifier id = r21(t); varParam = id;
			if (id!=null) { r22a(id); t1[0] = id.getType(); }
			loadID(id);
			}
			( <PARENTHESIS_OPEN>
			  {r22(id);} nPar = Arguments(id) {r24(id,nPar); }
			  <PARENTHESIS_CLOSE> )?
			  VariableAux(id, t1) 
				{
					tipo[0] = t1[0];
				}
			| ( t = <INTEGER_CONST> 
				{
					r26i(t,minus);
					tipo[0] = STManager.getTypeInteger();
					loadInt(t);
				} 
			| t = <REAL_CONST> 
				{
					r26r(t,minus);
					tipo[0] = STManager.getTypeReal();
					loadReal(t);
				} 
			  )
	
			| t = <STRING_CONST> 
				{
					{ r26s(t); }
					tipo[0] = STManager.getTypeString();
					loadString(t);
				}
			| <NOT> Factor(false,t1)  
				{
					if (!validLogicType(t1[0]))
						error(ErrorConstants.ERR_INT_BOOL_EXPECTED);
					else tipo[0] = STManager.getTypeBoolean();
				}
			| <PARENTHESIS_OPEN> Condition(t1) <PARENTHESIS_CLOSE> 
				{
					tipo[0] = t1[0];
				}
		)
		{ return varParam; }
	}

	void Bool(): {} { 
		( <TRUE> | <FALSE> ) 
	}

	// Apenas faz atribuição de tipos
	ArrayList<Identifier> Variable(Identifier tipo[]): {Token t; Identifier id;
		ArrayList<Identifier> ids = new ArrayList<Identifier>();} {
		t = <IDENTIFIER> {id = r21(t); if (id!=null) { ids.add(id); tipo[0] = id.getType(); } }
		id = VariableAux(id, tipo) { if (id != null) ids.add(id); }
		{ return ids; }
	}

	// Apenas faz atribuição de tipos
	Identifier VariableAux(Identifier id, Identifier tipo[]): {Token t; Identifier aux = null;} {
		{
			Identifier t1[] = new Identifier[1];
		}
		( <DOT> { rVP(id); } t = <IDENTIFIER> {aux = r21a(id,t);
		if (aux!=null) { tipo[0] = aux.getType(); } }
		| <BRACKET_OPEN> Expression(t1) {
			testInteger(t1[0]);
			if (id!=null && id.getType()!=null) tipo[0] = id.getType().getArrayType();
		} <BRACKET_CLOSE> )*
		{ return aux; }
	}
	void Argument(): {} { Condition(null) }

	TOKEN_MGR_DECLS :
	{
		public void CommonTokenAction(Token t)
		{
			t.absoluteBeginColumn = getCurrentTokenAbsolutePosition();
			t.absoluteEndColumn = t.absoluteBeginColumn + t.image.length();
		}

		public int getCurrentTokenAbsolutePosition()
		{
			if (input_stream instanceof SimpleCharStream)
				return ((SimpleCharStream)input_stream).getAbsoluteTokenBengin();
			return -1;
		}
	}