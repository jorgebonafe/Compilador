/**
 ** -  JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */
options {
	static = false;
	ERROR_REPORTING = true;
	TRACK_TOKENS =true;
	TOKEN_EXTENDS ="BaseToken"; 
	COMMON_TOKEN_ACTION=true;
	//  DEBUG_PARSER = true;
}

PARSER_BEGIN(JASON)
package testJJ;

import java.io.InputStream;
import java.util.ArrayList;
import java.util.HashMap;

public class JASON {
	int errorCode = 0;
	String result = "";
	String errorMessage = "";
	int currentLevel;
	SymbolTableManager STManager;
	ArrayList<String> errorParams;
	ArrayList<Token> errorTokenParams;
	HashMap<String,String> definitions;
	int offset = 0;

	Identifier current_id = null;
	Identifier proc_id = null;
	boolean permissao_tipo_array = false;
	boolean permissao_tipo_record = false;
	int classe_t;

	public Identifier r0(Token t) throws ParseException {
		Identifier id = new Identifier();
		id.setID(t.image.toUpperCase());
		id.setLevel(currentLevel);

		if (!STManager.addSymbol(id)) {
			errorCode = ErrorConstants.ERR_DUPLICATE_IDENTIFIER;
			errorParams = new ArrayList<String>();
			errorParams.add(id.getID());
			throw generateParseException();
		}
		return id;
	}

	public void r0a(Identifier id, int cat, Identifier type, String value) {
		id.setCategory(cat);
		id.setType(type);		id.setValue(value);
	}

	public Identifier r1(Token t) throws ParseException {
		Identifier id = new Identifier();
		id.setID(t.image.toUpperCase());
		id.setLevel(currentLevel);
		id.setCategory(SymbolTableManager.CATEGORY_TYPE);

		if (!STManager.addSymbol(id)) {
			errorCode = ErrorConstants.ERR_DUPLICATE_IDENTIFIER;
			errorParams = new ArrayList<String>();
			errorParams.add(id.getID());
			throw generateParseException();
		}
		permissao_tipo_array = true;
		permissao_tipo_record = true;

		return id;
	}

	public void r2a(){}

	public void r3(Token t, Identifier type) throws ParseException {
		Identifier id = new Identifier();
		id.setID(t.image.toUpperCase());
		id.setLevel(currentLevel);
		id.setType(type);
		id.setCategory(SymbolTableManager.CATEGORY_VAR);

		if (!STManager.addSymbol(id)) {
			errorCode = ErrorConstants.ERR_DUPLICATE_IDENTIFIER;
			errorParams = new ArrayList<String>();
			errorParams.add(id.getID());
			throw generateParseException();
		}
		permissao_tipo_array = true;
		permissao_tipo_record = true;
	}

	public void r4(){}

	public void r4a(){}

	public Identifier r5(Token t) throws ParseException {
		Identifier id = new Identifier();
		id.setID(t.image.toUpperCase());
		id.setLevel(currentLevel);
		id.setCategory(SymbolTableManager.CATEGORY_PROCEDURE);
		if (!STManager.addSymbol(id)) {
			errorCode = ErrorConstants.ERR_DUPLICATE_IDENTIFIER;
			errorParams = new ArrayList<String>();
			errorParams.add(id.getID());
			throw generateParseException();
		}
		return id;
	}

	public Identifier r6(Token t) throws ParseException {
		Identifier id = new Identifier();
		id.setID(t.image.toUpperCase());
		id.setLevel(currentLevel);
		id.setCategory(SymbolTableManager.CATEGORY_FUNCTION);
		if (!STManager.addSymbol(id)) {
			errorCode = ErrorConstants.ERR_DUPLICATE_IDENTIFIER;
			errorParams = new ArrayList<String>();
			errorParams.add(id.getID());
			throw generateParseException();
		}
		return id;
	}

	public void r7(){}

	public Identifier r7a(Token t) throws ParseException {
		Identifier id = STManager.getIdentifier(t.image);
		if (id.getCategory() != SymbolTableManager.CATEGORY_TYPE) {
			errorCode = ErrorConstants.ERR_TYPE_NOT_DECLARED;
			errorParams = new ArrayList<String>();
			errorParams.add(id.getID());
			throw generateParseException();
		}
		return id;
	}

	public void r8(){}

	public void r10(Identifier id) throws ParseException {
		if (permissao_tipo_array) {
			id.setType(STManager.getTypeArray());
			permissao_tipo_array = false;		}
		else {
			errorCode = ErrorConstants.ERR_MULTIDIM_ARRAY;
			throw generateParseException();		}
	}

	public void r10a(Identifier id) throws ParseException {
		if (permissao_tipo_record) {
			id.setType(STManager.getTypeRecord());
			permissao_tipo_record = false;
		}
		else {
			errorCode = ErrorConstants.ERR_MULTIDIM_RECORD;
			throw generateParseException();
		}
	}

	public void r12(Identifier id, Token t, Identifier dt) throws ParseException {
		int size = new Integer(t.image);
		if (size<=0) {
			errorCode = ErrorConstants.ERR_NEGATIVE_ARRAY;
			errorTokenParams = new ArrayList<Token>();
			errorTokenParams.add(t);
			throw generateParseException();
		}
		id.setArraySize(new Integer(t.image));
		id.setArrayType(dt);
		id.setNBytes(dt.getNBytes()*id.getArraySize());
	}

	public void r12a(Identifier id, Token t, Identifier dt) {
		Identifier aux = new Identifier();
		aux.setID(t.image.toUpperCase());
		aux.setLevel(currentLevel);
		aux.setType(dt);
		id.setNBytes(dt.getNBytes());
		aux.setCategory(SymbolTableManager.CATEGORY_VAR);
		
		id.setNBytes(id.getNBytes()+dt.getNBytes());
		id.getRecordTypes().add(aux);
	}

	public void r13(Identifier id) {
		permissao_tipo_array = true;
		proc_id = id;
	}

	public void r14() {
		classe_t = SymbolTableManager.TRANSFER_VALUE;
	}

	public void r15() {
		classe_t = SymbolTableManager.TRANSFER_REF;
	}

	public void r16(){}

	public void r17(){}

	public void r18(){}

	public void r19(){}

	public void r20(){}

	public Identifier r21(Token t) throws ParseException {
		Identifier id = STManager.getIdentifier(t.image);
		if (id==null) {
			errorCode = ErrorConstants.ERR_IDENTIFIER_NOT_DECLARED;
			errorParams = new ArrayList<String>();
			errorParams.add(t.image.toUpperCase());
			throw generateParseException();
		}

		current_id = id;
		return id;
	}

	public void r21a(Identifier id,Token t) throws ParseException {
		Identifier aux = STManager.getRecordIdentifier(id,t.image);
		if (aux==null) {
			errorCode = ErrorConstants.ERR_IDENTIFIER_NOT_DECLARED;
			errorParams = new ArrayList<String>();
			errorParams.add(t.image.toUpperCase());
			throw generateParseException();
		}

		current_id = aux;
	}

	public void r22() throws ParseException {
		if (current_id.getCategory() != SymbolTableManager.CATEGORY_FUNCTION)
		{
			errorCode = ErrorConstants.ERR_FUNCTION_NOT_DECLARED;
			errorParams = new ArrayList<String>();
			errorParams.add(current_id.getID());
			throw generateParseException();
		}
	}

	public void r22a() throws ParseException {
		if (current_id.getCategory() != SymbolTableManager.CATEGORY_FUNCTION ||
			current_id.getCategory() != SymbolTableManager.CATEGORY_PARAM ||
			current_id.getCategory() != SymbolTableManager.CATEGORY_VAR ||
			current_id.getCategory() != SymbolTableManager.CATEGORY_CONST)
		{
			errorCode = ErrorConstants.ERR_FPVC_NOT_DECLARED;
			errorParams = new ArrayList<String>();
			errorParams.add(current_id.getID());
			throw generateParseException();
		}
	}

	public void r23(){}

	public void r24(int nPar) throws ParseException {
		if (current_id.getNParameters() != nPar)		{			errorCode = ErrorConstants.ERR_N_PAR_INCOMPATICLE;
			throw generateParseException();
		}
	}

	public void r25() throws ParseException {
		if (current_id.getCategory() != SymbolTableManager.CATEGORY_PROCEDURE)
		{
			errorCode = ErrorConstants.ERR_PROCEDURE_NOT_DECLARED;
			errorParams = new ArrayList<String>();
			errorParams.add(current_id.getID());
			throw generateParseException();
		}
	}

	public void r26(){}

	public int getErrorCode()
	{
		return errorCode;
	}

	public String getErrorMessage()
	{
		return errorMessage;
	}

	public String testParser(InputStream is)	{
		ReInit(is);
		result = "";
		errorCode = 0;
		int currentLevel = 0;
		STManager = new SymbolTableManager();

		try {
			this.Program();
			result += "OK.\u005cn";
		} catch (ParseException e) {
			switch (errorCode)
			{
			case ErrorConstants.ERR_MULTIDIM_ARRAY: 
				errorMessage = "Arrays de múltiplas dimensões não"+
						" são permitidos, linha "+
						e.currentToken.beginLine + ", coluna "
						+ e.currentToken.beginColumn;
				break;
			case ErrorConstants.ERR_DUPLICATE_IDENTIFIER: 
				errorMessage = "Identificador duplicado ("+
						errorParams.get(0)+
						") na linha " + e.currentToken.beginLine + ", coluna "
						+ e.currentToken.beginColumn;
				break;
			case ErrorConstants.ERR_IDENTIFIER_NOT_DECLARED: 
				errorMessage = "Identificador não declarado ("+
						errorParams.get(0)+
						") na linha " + e.currentToken.beginLine + ", coluna "
						+ e.currentToken.beginColumn;
				break;
			case ErrorConstants.ERR_FUNCTION_NOT_DECLARED: 
				errorMessage = "Função não declarada ("+
						errorParams.get(0)+
						") na linha " + e.currentToken.beginLine + ", coluna "
						+ e.currentToken.beginColumn;
				break;
			case ErrorConstants.ERR_TYPE_NOT_DECLARED: 
				errorMessage = "Tipo não declarado ("+
						errorParams.get(0)+
						") na linha " + e.currentToken.beginLine + ", coluna "
						+ e.currentToken.beginColumn;
				break;
			case ErrorConstants.ERR_N_PAR_INCOMPATICLE: 
				errorMessage = "Incompatibilidade no número "+
				"de parâmetros na linha " + e.currentToken.beginLine + ", coluna "
						+ e.currentToken.beginColumn;
				break;
			case ErrorConstants.ERR_FPVC_NOT_DECLARED: 
				errorMessage = "Função, parâmetro, variável ou constante não declarada ("+
						errorParams.get(0)+
						") na linha " + e.currentToken.beginLine + ", coluna "
						+ e.currentToken.beginColumn;
				break;
			case ErrorConstants.ERR_CONSTANT_NOT_DEFINED: 
				errorMessage = "Constante não definida ("+
						errorParams.get(0)+
						") na linha " + e.currentToken.beginLine + ", coluna "
						+ e.currentToken.beginColumn;
				break;
			case ErrorConstants.ERR_NEGATIVE_ARRAY: 
				errorMessage = "Array de tamanho não positivo "+
					") na linha " +
					errorTokenParams.get(0).beginLine + ", coluna "+
					errorTokenParams.get(0).beginColumn;
				break;
			default:
				errorCode = -1;
				errorMessage += e.getMessage() + "\u005cn";
			}

			ReInit(is);
		}
		catch (Exception e) {
			errorCode = -1;
			errorMessage += e.getMessage() + "\u005cn";
			ReInit(is);
		} catch (Error e) {
			errorCode = -1;
			errorMessage += e.getMessage() + "\u005cn";
		}

		/*
		Token t = null;
		Token previousT = null;
		Token lastStringT = null;
		Token lastCommentT = null;
		outerloop:
		while (true)
		{
			try
			{
				t = getNextToken();
				String tokenName = "";
				if (t.kind != 0)
				{
					int spaces = 0;
					spaces = 4 - new Integer(t.beginLine).toString().length();
					if (spaces<0)
						spaces = 0;
					int spaces2 = 3 - new Integer(t.beginColumn).toString().length();
					if (spaces2 < 0)
						spaces2 = 0;

					result = result + "(";
					for (int i=0;i<spaces;i++)
						result = result + " ";
					result = result + t.beginLine + ",";
					for (int i=0;i<spaces2;i++)
						result = result + " ";
					result = result + t.beginColumn + ")   ";
				}
				switch (t.kind)
				{
					case ARRAY : 
					tokenName = "ARRAY";
					break;
					case BEGIN : 
					tokenName = "BEGIN";
					break;
					case CALL : 
					tokenName = "CALL";
					break;
					case DO : 
					tokenName = "DO";
					break;
					case ELSE : 
					tokenName = "ELSE";
					break;
					case END : 
					tokenName = "END";
					break;
					case ENDIF : 
					tokenName = "ENDIF";
					break;
					case ENDUNTIL : 
					tokenName = "ENDUNTIL";
					break;
					case ENDWHILE : 
					tokenName = "ENDWHILE";
					break;
					case FUNCTION : 
					tokenName = "FUNCTION";
					break;
					case IF : 
					tokenName = "IF";
					break;
					case INTEGER : 
					tokenName = "INTEGER";
					break;
					case PARAMETERS : 
					tokenName = "PARAMETERS";
					break;
					case PROCEDURE : 
					tokenName = "PROCEDURE";
					break;
					case RETURNS : 
					tokenName = "RETURNS";
					break;
					case PROGRAM : 
					tokenName = "PROGRAM";
					break;
					case READ : 
					tokenName = "READ";
					break;
					case REAL : 
					tokenName = "REAL";
					break;
					case RECORD : 
					tokenName = "RECORD";
					break;
					case RETURN : 
					tokenName = "RETURN";
					break;
					case SET : 
					tokenName = "SET";
					break;
					case STRING : 
					tokenName = "STRING";
					break;
					case THEN : 
					tokenName = "THEN";
					break;
					case TYPES : 
					tokenName = "TYPES";
					break;
					case UNTIL : 
					tokenName = "UNTIL";
					break;
					case VAR : 
					tokenName = "VAR";
					break;
					case VARIABLES : 
					tokenName = "VARIABLES";
					break;
					case WHILE : 
					tokenName = "WHILE";
					break;
					case WRITE : 
					tokenName = "WRITE";
					break;
					case BOOLEAN : 
					tokenName = "BOOLEAN";
					break;
					case TRUE : 
					tokenName = "TRUE";
					break;
					case FALSE : 
					tokenName = "FALSE";
					break;
					case DEFINE : 
					tokenName = "DEFINE";
					break;
					case OP_ADD : 
					tokenName = "OP_ADD";
					break;
					case OP_SUB : 
					tokenName = "OP_SUB";
					break;
					case OP_MULT : 
					tokenName = "OP_MULT";
					break;
					case OP_DIV : 
					tokenName = "OP_DIV";
					break;
					case OP_MOD : 
					tokenName = "OP_MOD";
					break;
					case OP_EQUALS : 
					tokenName = "OP_EQUALS";
					break;
					case OP_LESS : 
					tokenName = "OP_LESS";
					break;
					case OP_GREATER : 
					tokenName = "OP_GREATER";
					break;
					case OP_LESS_OR_EQUAL : 
					tokenName = "OP_LESS_OR_EQUAL";
					break;
					case OP_GREATER_OR_EQUAL : 
					tokenName = "OP_GREATER_OR_EQUAL";
					break;
					case OP_DIFFERENT : 
					tokenName = "OP_DIFFERENT";
					break;
					case BRACKET_OPEN : 
					tokenName = "BRACKET_OPEN";
					break;
					case BRACKET_CLOSE : 
					tokenName = "BRACKET_CLOSE";
					break;
					case PARETHESIS_OPEN : 
					tokenName = "PARETHESIS_OPEN";
					break;
					case PARETHESIS_CLOSE : 
					tokenName = "PARETHESIS_CLOSE";
					break;
					case COMMA : 
					tokenName = "COMMA";
					break;
					case DOT : 
					tokenName = "DOT";
					break;
					case SEMICOLON : 
					tokenName = "SEMICOLON";
					break;
					case AND : 
					tokenName = "AND";
					break;
					case OR : 
					tokenName = "OR";
					break;
					case NOT : 
					tokenName = "NOT";
					break;
					case INTEGER_CONST : 
					tokenName = "INTEGER_CONST";
					break;
					case REAL_CONST : 
					tokenName = "REAL_CONST";
					break;
					case IDENTIFIER : 
					tokenName = "IDENTIFIER";
					break;
					case COMMENT_CORE : 
					lastCommentT = t.specialToken;
					case STRING_CORE : 
					lastStringT = t.specialToken;
					break;
					case STRING_CONST : 
					tokenName = "STRING_CONST";
					break;
					case EOF :
						if (previousT != null && previousT.kind == COMMENT_CORE) {
								errorCode = 2;
							errorMessage = "Comentário de bloco na linha "+
							lastCommentT.beginLine + ", coluna "+lastCommentT.beginColumn + " nunca foi fechado.";
						}					
						if (t.specialToken != null &&
							t.specialToken.kind == COMMENT_INNER) {
								errorCode = 2;
							errorMessage = "Comentário de bloco na linha "+
							t.beginLine + ", coluna "+t.beginColumn + " nunca foi fechado.";
						}
						else if (previousT != null && previousT.kind == STRING_CORE) {
								errorCode = 3;
							errorMessage = "String na linha "+
							lastStringT.beginLine + ", coluna "+lastStringT.beginColumn + " nunca foi fechada.";
						}
						else if (t.specialToken != null &&
							t.specialToken.kind == STRING_START) {
								errorCode = 3;
							errorMessage = "String na linha "+
							t.specialToken.beginLine + ", coluna "+t.specialToken.beginColumn + " nunca foi fechada.";
						}

					break outerloop;
					case IDENTIFIER_ERR : 
					errorCode = 1;
					errorMessage = "Identificador muito longo na linha " +
						t.beginLine + ", coluna "+t.beginColumn +
						". Tamanho máximo é 63 caracteres.";
					break outerloop;
					default:
					break outerloop;
				}
				previousT = t;

				int spaces = 0;
				spaces = 16 - tokenName.length();

				for (int i=0;i<spaces;i++)
					result = result + " ";

				result = result + tokenName + ": " + t.image + "\n";
			}
			catch (Exception e)
			{}
			catch (TokenMgrError e)
			{
				errorCode = 1;
				errorMessage = e.getMessage();
				break;
			}
		}

		 */
		return result;
	}
}

PARSER_END(JASON)

SKIP :
{
	" "
	| "\r"
	| "\r\n"
	| "\t"
	| "\n"
}

SPECIAL_TOKEN:
{
		<COMMENT_LINE: "#" (~["\n","\r","\r"])* >
		| < COMMENT_INNER : "{" >: IN_COMMENT
		| < COMMENT_BLOCK : "{" (~["}"])* "}" >
}


	< IN_COMMENT > TOKEN : {
		< COMMENT_CORE: (~["}"])* > : DEFAULT
	}

	TOKEN [IGNORE_CASE] : /* RESERVED WORDS */
	{
		< ARRAY : "ARRAY" >
		| < BEGIN : "BEGIN" >
		| < CALL : "CALL" >
		| < DO : "DO" >
		| < ELSE : "ELSE" >
		| < END : "END" >
		| < ENDIF : "ENDIF" >
		| < ENDUNTIL : "ENDUNTIL" >
		| < ENDWHILE : "ENDWHILE" >
		| < FUNCTION : "FUNCTION" >
		| < IF : "IF" >
		| < INTEGER : "INTEGER" >
		| < PARAMETERS : "PARAMETERS" >
		| < PROCEDURE : "PROCEDURE" >
		| < RETURNS : "RETURNS" >
		| < PROGRAM : "PROGRAM" >
		| < READ : "READ" >
		| < REAL : "REAL" >
		| < RECORD : "RECORD" >
		| < RETURN : "RETURN" >
		| < SET : "SET" >
		| < STRING : "STRING" >
		| < THEN : "THEN" >
		| < TYPES : "TYPES" >
		| < UNTIL : "UNTIL" >
		| < VAR : "VAR" >
		| < VARIABLES : "VARIABLES" >
		| < WHILE : "WHILE" >
		| < WRITE : "WRITE" >
		| < BOOLEAN : "BOOLEAN" >
		| < TRUE : "TRUE" >
		| < FALSE : "FALSE" >
		| < DEFINE : "DEFINE" >
	}

	TOKEN : /* OPERATORS */
	{
		< OP_ADD : "+" >
		| < OP_SUB : "-" >
		| < OP_MULT : "*" >
		| < OP_DIV : "/" >
		| < OP_MOD : "%" >
		| < OP_EQUALS: "=" >
		| < OP_LESS: "<" >
		| < OP_GREATER: ">" >
		| < OP_LESS_OR_EQUAL: "<=" >
		| < OP_GREATER_OR_EQUAL: ">=" >
		| < OP_DIFFERENT: "!" >
	}

	TOKEN : /* SYMBOLS */
	{
		< BRACKET_OPEN : "[" >
		| < BRACKET_CLOSE : "]" >
		| < PARETHESIS_OPEN : "(" >
		| < PARETHESIS_CLOSE: ")" >
		| < COMMA : "," >
		| < DOT : "." >
		| < SEMICOLON  : ";" >
		| < AND : "&" >
		| < OR : "\\" >
		| < NOT : "~" >
	}

	TOKEN :
	{
		< INTEGER_CONST : (< DIGIT >)+ >
		| < REAL_CONST : (< DIGIT >)+"."(< DIGIT >)* | "."(< DIGIT >)+ >
		| < #DIGIT : [ "0"-"9" ] >
	}

	TOKEN [IGNORE_CASE]:
	{
		< IDENTIFIER : [ "a"-"z", "_" ]([ "a"-"z" , "0"-"9", "_"]){0,62} >
		| < IDENTIFIER_ERR : [ "a"-"z", "_" ]([ "a"-"z" , "0"-"9", "_"]){63,} >
	}

	SPECIAL_TOKEN:
	{
		< STRING_START : "\"" >: IN_STRING
	}

	< IN_STRING > TOKEN :
	{
		< STRING_CORE:  (~["\""])* > : DEFAULT 
	}

	TOKEN [IGNORE_CASE]:
	{
		< STRING_CONST : "\"" (~["\""])*  "\"" > 
	}


	void Program(): {} { Header() DeclSec() Block() <DOT> }
	void Header(): {} { <PROGRAM> <IDENTIFIER> <SEMICOLON> }
	void Block(): {} { <BEGIN> Statements() <END> }

	//Declarações

	void DeclSec(): {} { 
		(DefineDeclSec())? (TypeDeclSec())? (VarDeclSec())? (SubProgramDecls())? 
	}

	void DefineDeclSec():
	{
		Token t;
		Identifier type[] = new Identifier[1];
		String value[] = new String[1];
	} { 
		<DEFINE> ( t = <IDENTIFIER> { Identifier id = r0(t);}
		<OP_EQUALS> Values(id, type,value)
		<SEMICOLON> {r0a(id,SymbolTableManager.CATEGORY_CONST,type[0],value[0]);})+ 
	}

	String Values(Identifier id, Identifier type[], String value[]): {Token t1 = null; Token t2;} {
		( ( t1 = <OP_SUB> )?
				(  t2 = <INTEGER_CONST>
				{type[0] = STManager.getTypeInteger();value[0]=t2.image;}
				| t2 = <REAL_CONST>
				{type[0] = STManager.getTypeReal();value[0]=t2.image;})
				| t2 = <STRING_CONST>
				{type[0] = STManager.getTypeString();value[0]=t2.image;})
		{
			String s = "";
			if (t1 != null)
				s = s+t1.image.toUpperCase();
			s = s+t2.image.toUpperCase();
			return s;
		}
	}

	void TypeDeclSec(): {Token t; Identifier id;} { 
		<TYPES> ( t = <IDENTIFIER> {id = r1(t);} ( ArraySpecification(id) |
		RecordSpecification(id) ) <SEMICOLON> )+ 
	}

	void ArraySpecification(Identifier id): {Identifier dt;Token t;} { 
		<ARRAY> {r10(id);}
		dt = DataType() <BRACKET_OPEN> t = <INTEGER_CONST>
		{r12(id,t,dt);} <BRACKET_CLOSE> 
	}

	void RecordSpecification(Identifier id): {} { 
		<RECORD> {r10a(id);} VarDeclsRecord(id) <END>
	}

	void VarDeclsRecord(Identifier id): {Identifier dt;} {
		( dt = DataType() IdListRecord(id,dt) <SEMICOLON> )+
	}

	void VarDeclSec(): {} { 
		<VARIABLES> VarDecls() 
	}

	void VarDecls(): {Identifier dt;} {
		( dt = DataType() IdList(dt) <SEMICOLON> )+
	}

	Identifier DataType(): {Token t; Identifier id;} {
		(
			t = <REAL> {id = STManager.getTypeReal(); } |
			t = <INTEGER> {id = STManager.getTypeInteger(); } |
			t = <IDENTIFIER> { id = r7a(t); } |
			t = <STRING> {id = STManager.getTypeString(); } |
			t = <BOOLEAN> {id = STManager.getTypeBoolean(); } )
		{
			return id;
		}
	}

	void IdList(Identifier dt): {Token t;} {
		t = <IDENTIFIER>
		{r3(t,dt);}
		( <COMMA> t = <IDENTIFIER>
		{r3(t,dt);}
				)*
	}

	void IdListRecord(Identifier id, Identifier dt): {Token t;} {
		t = <IDENTIFIER>
		{r12a(id,t,dt);}
		( <COMMA> t = <IDENTIFIER>
		{r12a(id,t,dt);}
		)*
	}

	void SubProgramDecls(): {} { 
		( ProcDecl() | FunctionDecl() )+ 
	}

	void ProcDecl(): {} {
		ProcHeader()
		{
			currentLevel++;
		}
		SubProgramDeclSec() Block() {r8();}
		{
			STManager.removeLevel(currentLevel);
			currentLevel--;
		}
		<SEMICOLON>
	}

	void ProcHeader(): {Token t;} {
		<PROCEDURE> t = <IDENTIFIER> { Identifier id = r5(t); r13(id); }
		<SEMICOLON>
	}

	void SubProgramDeclSec(): {} {
		(ParamDeclSec())? DeclSec() 
	}

	void ParamDeclSec(): {Identifier dt;Token t;Token tTransf = null;} {
		{
			ArrayList<Identifier> idList = new ArrayList<Identifier>();
			Identifier id;
		}
		<PARAMETERS> ( {r14();} (tTransf = <VAR> {r15();})?
				dt = DataType() {r19();}
		t = <IDENTIFIER> {r18();}
		{
			id = new Identifier();
			id.setID(t.image.toUpperCase());
			id.setLevel(currentLevel);
			id.setType(dt);
			id.setCategory(SymbolTableManager.CATEGORY_PARAM);
			if (tTransf==null) {
				id.setTransferType(SymbolTableManager.TRANSFER_VALUE);
			}
			else {
				id.setTransferType(SymbolTableManager.TRANSFER_REF);
			}
			idList.add(id);
		}
		<SEMICOLON> )+ {r20();}
		{
			for (Identifier identifier : idList) {
				if (!STManager.addSymbol(identifier))
				{
					errorCode = ErrorConstants.ERR_DUPLICATE_IDENTIFIER;
					errorParams = new ArrayList<String>();
					errorParams.add(id.getID());
					throw generateParseException();
				}
			}
		}
	} 

	void FunctionDecl(): {} {
		FunctionHeader()
		{
			currentLevel++;
		}
		SubProgramDeclSec() FunctionBlock() {r8();}
		{
			STManager.removeLevel(currentLevel);
			currentLevel--;
		}
		<SEMICOLON>
	}

	void FunctionHeader(): {Token t;Identifier dt;} {
		<FUNCTION> t = <IDENTIFIER> { Identifier id = r6(t); r13(id);}
		<RETURNS> dt = DataType() {r7();}
		{
			id = new Identifier();
			id.setID(t.image.toUpperCase());
			id.setLevel(currentLevel);
			id.setType(dt);
			id.setCategory(SymbolTableManager.CATEGORY_FUNCTION);
			if (!STManager.addSymbol(id))
			{
				errorCode = ErrorConstants.ERR_DUPLICATE_IDENTIFIER;
				errorParams = new ArrayList<String>();
				errorParams.add(id.getID());
				throw generateParseException();
			}
		}
		<SEMICOLON>
	}
	void FunctionBlock(): {} { <BEGIN> ( Statement() <SEMICOLON> )+  <RETURN> <PARETHESIS_OPEN> Condition() <PARETHESIS_CLOSE> <END> }

	//Comandos

	void Statements(): {} { Statement() ( <SEMICOLON> Statement() )* }
	void Statement(): {Token t;} { 
		( <READ> Variable() 
		| <SET> Variable() <OP_EQUALS> Expression()
		| <WRITE> Variable() 
		| <IF> Condition() <THEN> Statements() ElseClause() 
		| <WHILE> Condition() <DO> Statements() <ENDWHILE> | <UNTIL> Condition() <DO> Statements() <ENDUNTIL> 
		| <CALL> t = <IDENTIFIER> { r21(t); r25(); } ArgList()
		  )
	}

	void ElseClause(): {} {
		( <ELSE> Statements() )? <ENDIF> 
	}

	void ArgList(): {Token t = null; int nPar;} {
		( t = <PARETHESIS_OPEN> nPar = Arguments() <PARETHESIS_CLOSE>  {r24(nPar);} )?
	}

	int Arguments(): {int nArg = 1;} {
		Condition() (<COMMA> Condition() {nArg++;})*
		{ return nArg; }
	}


	//Expressões
	void Condition(): {} { 
		CompoundCondition() ( <OR> CompoundCondition() )* 
	}

	void CompoundCondition(): {} { 
		SimpleCondition() ( <AND> SimpleCondition() )* 
	}

	void SimpleCondition(): {} { 
		Expression() (RelOp() Expression())? 
	}

	void Expression(): {} { 
		Term() ( AddOp() Term() )* 
	}

	void Term(): {} { 
		Unary() ( MultOp() Unary() )* 
	}

	void Unary(): {} { 
		( ( <OP_ADD> | <OP_SUB> ) )? Factor() 
	}

	void Factor(): {Token t;int nPar;} {
		Bool() |
		t = <IDENTIFIER> { Identifier id = r21(t); r22a();}
		( <PARETHESIS_OPEN> {r22();} nPar =  Arguments() {r24(nPar);} <PARETHESIS_CLOSE> )? VariableAux(id) 
		| (<INTEGER_CONST> | <REAL_CONST>) {r26();}
		| <STRING_CONST> 
		| <NOT> Factor() 
		| <PARETHESIS_OPEN> Condition() <PARETHESIS_CLOSE>
	}

	void Bool(): {} { 
		( <TRUE> | <FALSE> ) 
	}

	void Variable(): {Token t; Identifier id;} {
		t = <IDENTIFIER> {id = r21(t);}
		VariableAux(id)
	}

	void VariableAux(Identifier id): {Token t;} {
		( <DOT> t = <IDENTIFIER> {r21a(id,t);}
		| <BRACKET_OPEN>  Expression() <BRACKET_CLOSE> )*
	}
	void RelOp(): {} { ( <OP_EQUALS> | <OP_DIFFERENT> | <OP_GREATER_OR_EQUAL> | <OP_LESS_OR_EQUAL> | <OP_LESS> | <OP_GREATER> ) }
	void AddOp(): {} { ( <OP_ADD> | <OP_SUB> ) }
	void MultOp(): {} { ( <OP_MULT> | <OP_DIV> | <OP_MOD> ) }
	void Argument(): {} { Condition() }

	TOKEN_MGR_DECLS :
	{
		public void CommonTokenAction(Token t)
		{
			t.absoluteBeginColumn = getCurrentTokenAbsolutePosition();
			t.absoluteEndColumn = t.absoluteBeginColumn + t.image.length();
		}

		public int getCurrentTokenAbsolutePosition()
		{
			if (input_stream instanceof SimpleCharStream)
				return ((SimpleCharStream)input_stream).getAbsoluteTokenBengin();
			return -1;
		}
	}