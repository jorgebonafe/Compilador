/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */
options {
  static = false;
  ERROR_REPORTING = true;
  LOOKAHEAD = 2;
}

PARSER_BEGIN(JASON)
package testJJ;

import java.io.InputStream;

public class JASON {
	int errorCode = 0;
	String errorMessage = "";

	public int getErrorCode()
	{
		return errorCode;
	}

	public String getErrorMessage()
	{
		return errorMessage;
	}
	
	public String testParser(InputStream is)	{
		String result = "";
		errorCode = 0;
		
		try {
			this.Program();
			result += "OK.\u005cn";
		} catch (Exception e) {
			errorCode = 4;
			errorMessage += e.getMessage() + "\u005cn";
			ReInit(System.in);
		} catch (Error e) {
			errorMessage += e.getMessage() + "\u005cn";
		}

/*
		Token t = null;
		Token previousT = null;
		Token lastStringT = null;
		Token lastCommentT = null;
		outerloop:
		while (true)
		{
			try
			{
				t = getNextToken();
				String tokenName = "";
				if (t.kind != 0)
				{
					int spaces = 0;
					spaces = 4 - new Integer(t.beginLine).toString().length();
					if (spaces<0)
						spaces = 0;
					int spaces2 = 3 - new Integer(t.beginColumn).toString().length();
					if (spaces2 < 0)
						spaces2 = 0;

					result = result + "(";
					for (int i=0;i<spaces;i++)
						result = result + " ";
					result = result + t.beginLine + ",";
					for (int i=0;i<spaces2;i++)
						result = result + " ";
					result = result + t.beginColumn + ")   ";
				}
				switch (t.kind)
				{
					case ARRAY : 
					tokenName = "ARRAY";
					break;
					case BEGIN : 
					tokenName = "BEGIN";
					break;
					case CALL : 
					tokenName = "CALL";
					break;
					case DO : 
					tokenName = "DO";
					break;
					case ELSE : 
					tokenName = "ELSE";
					break;
					case END : 
					tokenName = "END";
					break;
					case ENDIF : 
					tokenName = "ENDIF";
					break;
					case ENDUNTIL : 
					tokenName = "ENDUNTIL";
					break;
					case ENDWHILE : 
					tokenName = "ENDWHILE";
					break;
					case FUNCTION : 
					tokenName = "FUNCTION";
					break;
					case IF : 
					tokenName = "IF";
					break;
					case INTEGER : 
					tokenName = "INTEGER";
					break;
					case PARAMETERS : 
					tokenName = "PARAMETERS";
					break;
					case PROCEDURE : 
					tokenName = "PROCEDURE";
					break;
					case RETURNS : 
					tokenName = "RETURNS";
					break;
					case PROGRAM : 
					tokenName = "PROGRAM";
					break;
					case READ : 
					tokenName = "READ";
					break;
					case REAL : 
					tokenName = "REAL";
					break;
					case RECORD : 
					tokenName = "RECORD";
					break;
					case RETURN : 
					tokenName = "RETURN";
					break;
					case SET : 
					tokenName = "SET";
					break;
					case STRING : 
					tokenName = "STRING";
					break;
					case THEN : 
					tokenName = "THEN";
					break;
					case TYPES : 
					tokenName = "TYPES";
					break;
					case UNTIL : 
					tokenName = "UNTIL";
					break;
					case VAR : 
					tokenName = "VAR";
					break;
					case VARIABLES : 
					tokenName = "VARIABLES";
					break;
					case WHILE : 
					tokenName = "WHILE";
					break;
					case WRITE : 
					tokenName = "WRITE";
					break;
					case BOOLEAN : 
					tokenName = "BOOLEAN";
					break;
					case TRUE : 
					tokenName = "TRUE";
					break;
					case FALSE : 
					tokenName = "FALSE";
					break;
					case DEFINE : 
					tokenName = "DEFINE";
					break;
					case OP_ADD : 
					tokenName = "OP_ADD";
					break;
					case OP_SUB : 
					tokenName = "OP_SUB";
					break;
					case OP_MULT : 
					tokenName = "OP_MULT";
					break;
					case OP_DIV : 
					tokenName = "OP_DIV";
					break;
					case OP_MOD : 
					tokenName = "OP_MOD";
					break;
					case OP_EQUALS : 
					tokenName = "OP_EQUALS";
					break;
					case OP_LESS : 
					tokenName = "OP_LESS";
					break;
					case OP_GREATER : 
					tokenName = "OP_GREATER";
					break;
					case OP_LESS_OR_EQUAL : 
					tokenName = "OP_LESS_OR_EQUAL";
					break;
					case OP_GREATER_OR_EQUAL : 
					tokenName = "OP_GREATER_OR_EQUAL";
					break;
					case OP_DIFFERENT : 
					tokenName = "OP_DIFFERENT";
					break;
					case BRACKET_OPEN : 
					tokenName = "BRACKET_OPEN";
					break;
					case BRACKET_CLOSE : 
					tokenName = "BRACKET_CLOSE";
					break;
					case PARETHESIS_OPEN : 
					tokenName = "PARETHESIS_OPEN";
					break;
					case PARETHESIS_CLOSE : 
					tokenName = "PARETHESIS_CLOSE";
					break;
					case COMMA : 
					tokenName = "COMMA";
					break;
					case DOT : 
					tokenName = "DOT";
					break;
					case SEMICOLON : 
					tokenName = "SEMICOLON";
					break;
					case AND : 
					tokenName = "AND";
					break;
					case OR : 
					tokenName = "OR";
					break;
					case NOT : 
					tokenName = "NOT";
					break;
					case INTEGER_CONST : 
					tokenName = "INTEGER_CONST";
					break;
					case REAL_CONST : 
					tokenName = "REAL_CONST";
					break;
					case IDENTIFIER : 
					tokenName = "IDENTIFIER";
					break;
					case COMMENT_CORE : 
					lastCommentT = t.specialToken;
					case STRING_CORE : 
					lastStringT = t.specialToken;
					break;
					case STRING_CONST : 
					tokenName = "STRING_CONST";
					break;
					case EOF :
						if (previousT != null && previousT.kind == COMMENT_CORE) {
								errorCode = 2;
							errorMessage = "Comentário de bloco na linha "+
							lastCommentT.beginLine + ", coluna "+lastCommentT.beginColumn + " nunca foi fechado.";
						}					
						if (t.specialToken != null &&
							t.specialToken.kind == COMMENT_INNER) {
								errorCode = 2;
							errorMessage = "Comentário de bloco na linha "+
							t.beginLine + ", coluna "+t.beginColumn + " nunca foi fechado.";
						}
						else if (previousT != null && previousT.kind == STRING_CORE) {
								errorCode = 3;
							errorMessage = "String na linha "+
							lastStringT.beginLine + ", coluna "+lastStringT.beginColumn + " nunca foi fechada.";
						}
						else if (t.specialToken != null &&
							t.specialToken.kind == STRING_START) {
								errorCode = 3;
							errorMessage = "String na linha "+
							t.specialToken.beginLine + ", coluna "+t.specialToken.beginColumn + " nunca foi fechada.";
						}
						
					break outerloop;
					case IDENTIFIER_ERR : 
					errorCode = 1;
					errorMessage = "Identificador muito longo na linha " +
						t.beginLine + ", coluna "+t.beginColumn +
						". Tamanho máximo é 63 caracteres.";
					break outerloop;
					default:
					break outerloop;
				}
				previousT = t;

				int spaces = 0;
				spaces = 16 - tokenName.length();

				for (int i=0;i<spaces;i++)
					result = result + " ";

				result = result + tokenName + ": " + t.image + "\n";
			}
			catch (Exception e)
			{}
			catch (TokenMgrError e)
			{
				errorCode = 1;
				errorMessage = e.getMessage();
				break;
			}
		}

		*/
		return result;
	}
}

PARSER_END(JASON)

SKIP :
{
  " "
| "\r"
| "\r\n"
| "\t"
| "\n"
}

SPECIAL_TOKEN:
{
  <COMMENT_LINE: "#" (~["\n","\r","\r"])* >
| < COMMENT_INNER : "{" >: IN_COMMENT
| < COMMENT_BLOCK : "{" (~["}"])* "}" >
}


< IN_COMMENT > TOKEN : {
  < COMMENT_CORE: (~["}"])* > : DEFAULT
}

TOKEN [IGNORE_CASE] : /* RESERVED WORDS */
{
  < ARRAY : "ARRAY" >
| < BEGIN : "BEGIN" >
| < CALL : "CALL" >
| < DO : "DO" >
| < ELSE : "ELSE" >
| < END : "END" >
| < ENDIF : "ENDIF" >
| < ENDUNTIL : "ENDUNTIL" >
| < ENDWHILE : "ENDWHILE" >
| < FUNCTION : "FUNCTION" >
| < IF : "IF" >
| < INTEGER : "INTEGER" >
| < PARAMETERS : "PARAMETERS" >
| < PROCEDURE : "PROCEDURE" >
| < RETURNS : "RETURNS" >
| < PROGRAM : "PROGRAM" >
| < READ : "READ" >
| < REAL : "REAL" >
| < RECORD : "RECORD" >
| < RETURN : "RETURN" >
| < SET : "SET" >
| < STRING : "STRING" >
| < THEN : "THEN" >
| < TYPES : "TYPES" >
| < UNTIL : "UNTIL" >
| < VAR : "VAR" >
| < VARIABLES : "VARIABLES" >
| < WHILE : "WHILE" >
| < WRITE : "WRITE" >
| < BOOLEAN : "BOOLEAN" >
| < TRUE : "TRUE" >
| < FALSE : "FALSE" >
| < DEFINE : "DEFINE" >
}

TOKEN : /* OPERATORS */
{
  < OP_ADD : "+" >
| < OP_SUB : "-" >
| < OP_MULT : "*" >
| < OP_DIV : "/" >
| < OP_MOD : "%" >
| < OP_EQUALS: "=" >
| < OP_LESS: "<" >
| < OP_GREATER: ">" >
| < OP_LESS_OR_EQUAL: "<=" >
| < OP_GREATER_OR_EQUAL: ">=" >
| < OP_DIFFERENT: "!" >
}

TOKEN : /* SYMBOLS */
{
  < BRACKET_OPEN : "[" >
| < BRACKET_CLOSE : "]" >
| < PARETHESIS_OPEN : "(" >
| < PARETHESIS_CLOSE: ")" >
| < COMMA : "," >
| < DOT : "." >
| < SEMICOLON  : ";" >
| < AND : "&" >
| < OR : "\\" >
| < NOT : "~" >
}

TOKEN :
{
  < INTEGER_CONST : (< DIGIT >)+ >
| < REAL_CONST : (< DIGIT >)+"."(< DIGIT >)* | "."(< DIGIT >)+ >
| < #DIGIT : [ "0"-"9" ] >
}

TOKEN [IGNORE_CASE]:
{
  < IDENTIFIER : [ "a"-"z", "_" ]([ "a"-"z" , "0"-"9", "_"]){0,62} >
  | < IDENTIFIER_ERR : [ "a"-"z", "_" ]([ "a"-"z" , "0"-"9", "_"]){63,} >
}

SPECIAL_TOKEN:
{
  < STRING_START : "\"" >: IN_STRING
}

< IN_STRING > TOKEN :
{
  < STRING_CORE:  (~["\""])* > : DEFAULT 
}

TOKEN [IGNORE_CASE]:
{
  < STRING_CONST : "\"" (~["\""])*  "\"" > 
}

void Program(): {} { Header() DeclSec() Block() <DOT> }
void Header(): {} { <PROGRAM> <IDENTIFIER> <SEMICOLON> }
void Block(): {} { <BEGIN> Statements() <END> }

//Declarações

void DeclSec(): {} { DefineDeclSec() TypeDeclSec() VarDeclSec() SubProgramDecls() }
void DefineDeclSec(): {} { (<DEFINE> DefineDecls())? }
void DefineDecls(): {} { (DefineDecl())+ }
void DefineDecl(): {} { <IDENTIFIER> <OP_EQUALS> Values() <SEMICOLON> }
void Values(): {} { ( <OP_SUB> )? (<INTEGER_CONST> | <REAL_CONST>) | <STRING_CONST>  }
void TypeDeclSec(): {} { (<TYPES> TypeDecls())? }
void TypeDecls(): {} { (TypeDecl())+ }
void TypeDecl(): {} { <IDENTIFIER> TypeSpecification() }
void TypeSpecification(): {} { ( ArraySpecification() | RecordSpecification() ) }
void ArraySpecification(): {} { <ARRAY> DataType() <BRACKET_OPEN> (<INTEGER_CONST> | <REAL_CONST>) <BRACKET_OPEN> <SEMICOLON> }
void RecordSpecification(): {} { <RECORD> VarDecls() <END> <SEMICOLON> }
void VarDeclSec(): {} { (<VARIABLES> VarDecls())? }
void VarDecls(): {} { (VarDecl())+ }
void VarDecl(): {} { DataType() IdList() <SEMICOLON> }
void DataType(): {} { ( <REAL> | <INTEGER> | <IDENTIFIER> | <STRING> | <BOOLEAN> ) }
void IdList(): {} { <IDENTIFIER> ( <COMMA> <IDENTIFIER> )* }
void SubProgramDecls(): {} { (SubProgramDecl())* }
void SubProgramDecl(): {} { ( ProcDecl() | FunctionDecl() ) }
void ProcDecl(): {} { ProcHeader() SubProgramDeclSec() Block() <SEMICOLON> }
void ProcHeader(): {} { <PROCEDURE> <IDENTIFIER> <SEMICOLON> }
void SubProgramDeclSec(): {} { ParamDeclSec() DeclSec() }
void ParamDeclSec(): {} { (<PARAMETERS> ParamDecls())? }
void ParamDecls(): {} { (ParamDecl()) }
void ParamDecl(): {} { (<VAR>)? DataType() <IDENTIFIER> <SEMICOLON> }
void FunctionDecl(): {} { FunctionHeader() SubProgramDeclSec() FunctionBlock() <SEMICOLON> }
void FunctionHeader(): {} { <FUNCTION> <IDENTIFIER> <RETURNS> DataType() <SEMICOLON> }
void FunctionBlock(): {} { <BEGIN> Statements() ReturnStatement() <END> }

//Comandos

void Statements(): {} { Statement() ( <SEMICOLON> Statement() )* }
void Statement(): {} { ( <READ> Variable() | <SET> Variable() <OP_EQUALS> Expression() | <WRITE> Variable() | <IF> Condition() <THEN> Statements() ElseClause() | <WHILE> Condition() <DO> Statements() <ENDWHILE> | <UNTIL> Condition() <DO> Statements() <ENDUNTIL> | <CALL> <IDENTIFIER> ArgList() )? }
void ElseClause(): {} { ( <ELSE> Statements() )? <ENDIF> }
void ReturnStatement(): {} { <SEMICOLON> <RETURN> <PARETHESIS_OPEN> Condition() <PARETHESIS_CLOSE> }
void ArgList(): {} { ( <PARETHESIS_OPEN> Arguments() <PARETHESIS_CLOSE> )? }
void Arguments(): {} { Argument() (<COMMA> Argument() )* }

//Expressões
void Condition(): {} { CompoundCondition() ( <OR> CompoundCondition() )* }
void CompoundCondition(): {} { SimpleCondition() ( <AND> SimpleCondition() )* }
void SimpleCondition(): {} { Expression() (RelOp() Expression())? }
void Expression(): {} { Term() ( AddOp() Term() )* }
void Term(): {} { Unary() ( MultOp() Unary() )* }
void Unary(): {} { ( ( <OP_ADD> | <OP_SUB> ) )? Factor() }
void Factor(): {} { ( Id() | (<INTEGER_CONST> | <REAL_CONST>) | <STRING_CONST> | <NOT> Factor() | <PARETHESIS_OPEN> Condition() <PARETHESIS_CLOSE> | Bool() ) }
void Bool(): {} { ( <TRUE> | <FALSE> ) }
void Id(): {} { <IDENTIFIER> ( ArgList() | ( <BRACKET_OPEN> Expression() <BRACKET_OPEN> )? VariableEx() )  }
void Variable(): {} { <IDENTIFIER> ( <BRACKET_OPEN> Expression() <BRACKET_OPEN> )? VariableEx() }
void VariableEx(): {} { (<DOT> <IDENTIFIER> ( <BRACKET_OPEN> Expression() <BRACKET_OPEN> )? )* }
void RelOp(): {} { ( <OP_EQUALS> | <OP_DIFFERENT> | <OP_GREATER_OR_EQUAL> | <OP_LESS_OR_EQUAL> | <OP_LESS> | <OP_GREATER> ) }
void AddOp(): {} { ( <OP_ADD> | <OP_SUB> ) }
void MultOp(): {} { ( <OP_MULT> | <OP_DIV> | <OP_MOD> ) }
void Argument(): {} { Condition() }























/*

void S(): {} { E() <EOF>                                   }
void E(): {} { LOOKAHEAD(2) <ID> ":=" E() | T() ("+" T())* }
void T(): {} { F() ("*" F())*                              }
void F(): {} { <NUM> | <ID> | "(" E() ")"                  }




1. <Program> ::= <Header> <DeclSec> <Block> "."
2. <Header> ::= "program" "identifier" ";"
3. <Block> ::= "begin" <Statements> "end"

Declarações
4. <DeclSec> ::= <DefineSec> <TypeDeclSec> <VarDeclSec> <SubProgramDecls>
5. <DefineSec> ::= [ "define" <DefineDecls> | nil ]
6. <DefineDecls> ::= <DefineDecl>+
7. <DefineDecl> ::= "identifier" "=" <Values> ;
8. <Values> ::= [ ( "-" )? "numericLiteral" | "stringLiteral" ]
9. <TypeDeclSec> ::= [ "types" <TypeDecls> | nil ]
10. <TypeDecls> ::= <TypeDecl>+
11. <TypeDecl> ::= "identifier" <TypeSpecification>
12. <TypeSpecification> ::= [ <ArraySpecification> | <RecordSpecification> ]
13. <ArraySpecification> ::= "array" <DataType> "[" "numericliteral" "]" ";"
14. <RecordSpecification> ::= "record" <VarDecls> "end" ";"
15. <VarDeclSec> ::= [ "variables" <VarDecls> | nil ]
16. <VarDecls> ::= <VarDecl>+
17. <VarDecl> ::= <DataType> <IdList> ";"
18. <DataType> ::= [ "real" | "integer" | "identifier" | "string" | "boolean" ]
19. <IdList> ::= "identifier" ( "," "identifier" )*
20. <SubProgramDecls> ::= [ <SubProgramDecl>+ | nil ]
21. <SubProgramDecl> ::= [ <ProcDecl> | <FunctionDecl> ]
22. <ProcDecl> ::= <ProcHeader> <SubProgramDeclSec> <Block> ";"
23. <ProcHeader> ::= "procedure" "identifier" ";"
24. <SubProgramDeclSec> ::= <ParamDeclSec> <DeclSec>
25. <ParamDeclSec> ::= [ "parameter" <ParamDecls> | nil ]
26. <ParamDecls> ::= <ParamDecl>+
27. <ParamDecl> ::= ("var")? <DataType> "identifier" ";"
28. <FunctionDecl> ::= <FunctionHeader> <SubProgramDeclSec> <FunctionBlock> ";"
29. <FunctionHeader> ::= "function" "identifier" "returns" <Datatype> ";"
30. <FunctionBlock> ::= "begin" <Statements> <ReturnStatement> "end"
Comandos
31. <Statements> ::= <Statement> ( ";" <Statement> )*
32. <Statement> ::= [ "read" <Variable> | "set" <Variable> "=" <Expression> | "write" <Variable> | "if" <Condition> "then" <Statements> <ElseClause> | "while" <Condition> "do" <Statements> "endwhile" | "until" <Condition> "do" <Statements> "enduntil" | "call" "identifier" <ArgList> | nil ]
33. <ElseClause> ::= ( "else" <Statements> )? "endif"
34. <ReturnStatement> ::= ";" "return" "(" <Condition> ")"
35. <ArgList> ::= [ "(" <Arguments> ")" | nil ]
36. <Arguments> ::= <Argument> ("," <Argument> )*
Expressões
37. <Condition> ::= <CompoundCondition> ( "\" <CompoundCondition> )*
38. <CompoundCondition> ::= <SimpleCondition> ( "&" <SimpleCondition> )*
39. <SimpleCondition> ::= <Expression> (<RelOp> <Expression>)?
40. <Expression> ::= <Term> ( <AddOp> <Term> )*
41. <Term> ::= <Unary> ( <MultOp> <Unary> )*
42. <Unary> ::= ( [ "+" | "-" ] )? <Factor>
43. <Factor> ::= [ <Id> | "numericliteral" | "stringliteral" | "~" <Factor> | "(" <Condition> ")" | <Bool> ]
44. <Bool> ::= [ "true" | "false" ]
45. <Id> ::= "identifier" [ <Arglist> | ( "[" <Expression> "]" )? <VariableEx> ] 
46. <Variable> ::= "identifier" ( "[" <Expression> "]" )? <VariableEx>
47. <VariableEx> ::= ("." "identifier" ( "[" <Expression> "]" )? )*
48. RelOp ::= [ "=" | "!" | ">=" | "<=" | "<" | ">" ]
49. AddOp ::= [ "+" | "-" ]
50. MultOp ::= [ "*" | "/" | "%" ]
51. Argument ::= <Condition>


*/